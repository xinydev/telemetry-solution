{
    "_type": "PMU_Specification",
    "document": {
        "timestamp": "11 Oct 10:34:51 2024",
        "copyright": "Copyright 2022-2023 Arm Ltd.",
        "confidential": false,
        "quality": "Release",
        "license": "Apache-2.0",
        "description": "Telemetry Specification (PMU Events, Metrics and Methodology) for Neoverse N3 processor"
    },
    "product_configuration": {
        "product_name": "Neoverse N3",
        "part_num": "0xd8e",
        "major_revision": 0,
        "minor_revision": 0,
        "implementer": "0x41",
        "architecture": "armv9.2",
        "pmu_architecture": "pmu_v3",
        "num_slots": 5,
        "num_bus_slots": 0
    },
    "events": {
        "SW_INCR": {
            "code": "0x0000",
            "title": "Instruction architecturally executed, Condition code check pass, software increment",
            "description": "Counts software writes to the PMSWINC_EL0 (software PMU increment) register. The PMSWINC_EL0 register is a manually updated counter for use by application software.\n\nThis event could be used to measure any user program event, such as accesses to a particular data structure (by writing to the PMSWINC_EL0 register each time the data structure is accessed).\n\nTo use the PMSWINC_EL0 register and event, developers must insert instructions that write to the PMSWINC_EL0 register into the source code.\n\nSince the SW_INCR event records writes to the PMSWINC_EL0 register, there is no need to do a read/increment/write sequence to the PMSWINC_EL0 register.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "L1I_CACHE_REFILL": {
            "code": "0x0001",
            "title": "Level 1 instruction cache refill",
            "description": "Counts cache line refills in the level 1 instruction cache caused by a missed instruction fetch. Instruction fetches may include accessing multiple instructions, but the single cache line allocation is counted once.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1I_TLB_REFILL": {
            "code": "0x0002",
            "title": "Level 1 instruction TLB refill",
            "description": "Counts level 1 instruction TLB refills from any Instruction fetch. If there are multiple misses in the TLB that are resolved by the refill, then this event only counts once. This event will not count if the translation table walk results in a fault (such as a translation or access fault), since there is no new translation created for the TLB.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_REFILL": {
            "code": "0x0003",
            "title": "Level 1 data cache refill",
            "description": "Counts level 1 data cache refills caused by speculatively executed load or store operations that missed in the level 1 data cache. This event only counts one event per cache line.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE": {
            "code": "0x0004",
            "title": "Level 1 data cache access",
            "description": "Counts level 1 data cache accesses from any load/store operations. Atomic operations that resolve in the CPUs caches (near atomic operations) counts as both a write access and read access. Each access to a cache line is counted including the multiple accesses caused by single instructions such as LDM or STM. Each access to other level 1 data or unified memory structures, for example refill buffers, write buffers, and write-back buffers, are also counted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_TLB_REFILL": {
            "code": "0x0005",
            "title": "Level 1 data TLB refill",
            "description": "Counts level 1 data TLB accesses that resulted in TLB refills. If there are multiple misses in the TLB that are resolved by the refill, then this event only counts once. This event counts for refills caused by preload instructions or hardware prefetch accesses. This event counts regardless of whether the miss hits in L2 or results in a translation table walk. This event will not count if the translation table walk results in a fault (such as a translation or access fault), since there is no new translation created for the TLB. This event will not count on an access from an AT(address translation) instruction.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "INST_RETIRED": {
            "code": "0x0008",
            "title": "Instruction architecturally executed",
            "description": "Counts instructions that have been architecturally executed.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "EXC_TAKEN": {
            "code": "0x0009",
            "title": "Exception taken",
            "description": "Counts any taken architecturally visible exceptions such as IRQ, FIQ, SError, and other synchronous exceptions. Exceptions are counted whether or not they are taken locally.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "EXC_RETURN": {
            "code": "0x000A",
            "title": "Instruction architecturally executed, Condition code check pass, exception return",
            "description": "Counts any architecturally executed exception return instructions. For example: AArch64: ERET",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "CID_WRITE_RETIRED": {
            "code": "0x000B",
            "title": "Instruction architecturally executed, Condition code check pass, write to CONTEXTIDR",
            "description": "Counts architecturally executed writes to the CONTEXTIDR_EL1 register, which usually contain the kernel PID and can be output with hardware trace.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "PC_WRITE_RETIRED": {
            "code": "0x000C",
            "title": "Instruction architecturally executed, Condition code check pass, Software change of the PC",
            "description": "Counts branch instructions that caused a change of Program Counter, which effectively causes a change in the control flow of the program.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BR_IMMED_RETIRED": {
            "code": "0x000D",
            "title": "Branch instruction architecturally executed, immediate",
            "description": "Counts architecturally executed direct branches.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BR_RETURN_RETIRED": {
            "code": "0x000E",
            "title": "Branch instruction architecturally executed, procedure return, taken",
            "description": "Counts architecturally executed procedure returns.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BR_MIS_PRED": {
            "code": "0x0010",
            "title": "Branch instruction speculatively executed, mispredicted or not predicted",
            "description": "Counts branches which are speculatively executed and mispredicted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CPU_CYCLES": {
            "code": "0x0011",
            "title": "Cycle",
            "description": "Counts CPU clock cycles (not timer cycles). The clock measured by this event is defined as the physical clock driving the CPU logic.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_PRED": {
            "code": "0x0012",
            "title": "Predictable branch instruction speculatively executed",
            "description": "Counts all speculatively executed branches.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "MEM_ACCESS": {
            "code": "0x0013",
            "title": "Data memory access",
            "description": "Counts memory accesses issued by the CPU load store unit, where those accesses are issued due to load or store operations. This event counts memory accesses no matter whether the data is received from any level of cache hierarchy or external memory. If memory accesses are broken up into smaller transactions than what were specified in the load or store instructions, then the event counts those smaller memory transactions.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1I_CACHE": {
            "code": "0x0014",
            "title": "Level 1 instruction cache access",
            "description": "Counts instruction fetches which access the level 1 instruction cache. Instruction cache accesses caused by cache maintenance operations are not counted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_WB": {
            "code": "0x0015",
            "title": "Level 1 data cache write-back",
            "description": "Counts write-backs of dirty data from the L1 data cache to the L2 cache. This occurs when either a dirty cache line is evicted from L1 data cache and allocated in the L2 cache or dirty data is written to the L2 and possibly to the next level of cache. This event counts both victim cache line evictions and cache write-backs from snoops or cache maintenance operations. The following cache operations are not counted:\n\n1. Invalidations which do not result in data being transferred out of the L1 (such as evictions of clean data),\n2. Full line writes which write to L2 without writing L1, such as write streaming mode.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE": {
            "code": "0x0016",
            "title": "Level 2 data cache access",
            "description": "Counts accesses to the level 2 cache due to data accesses. Level 2 cache is a unified cache for data and instruction accesses. Accesses are for misses in the first level data cache or translation resolutions due to accesses. This event also counts write back of dirty data from level 1 data cache to the L2 cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE_REFILL": {
            "code": "0x0017",
            "title": "Level 2 data cache refill",
            "description": "Counts cache line refills into the level 2 cache. Level 2 cache is a unified cache for data and instruction accesses. Accesses are for misses in the level 1 data cache or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE_WB": {
            "code": "0x0018",
            "title": "Level 2 data cache write-back",
            "description": "Counts write-backs of data from the L2 cache to outside the CPU. This includes snoops to the L2 (from other CPUs) which return data even if the snoops cause an invalidation. L2 cache line invalidations which do not write data outside the CPU and snoops which return data from an L1 cache are not counted. Data would not be written outside the cache when invalidating a clean cache line.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BUS_ACCESS": {
            "code": "0x0019",
            "title": "Bus access",
            "description": "Counts memory transactions issued by the CPU to the external bus, including snoop requests and snoop responses. Each beat of data is counted individually.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "INST_SPEC": {
            "code": "0x001B",
            "title": "Operation speculatively executed",
            "description": "Counts operations that have been speculatively executed.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "TTBR_WRITE_RETIRED": {
            "code": "0x001C",
            "title": "Instruction architecturally executed, Condition code check pass, write to TTBR",
            "description": "Counts architectural writes to TTBR0/1_EL1. If virtualization host extensions are enabled (by setting the HCR_EL2.E2H bit to 1), then accesses to TTBR0/1_EL1 that are redirected to TTBR0/1_EL2, or accesses to TTBR0/1_EL12, are counted. TTBRn registers are typically updated when the kernel is swapping user-space threads or applications.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BUS_CYCLES": {
            "code": "0x001D",
            "title": "Bus cycle",
            "description": "Counts bus cycles in the CPU. Bus cycles represent a clock cycle in which a transaction could be sent or received on the interface from the CPU to the external bus. Since that interface is driven at the same clock speed as the CPU, this event is a duplicate of CPU_CYCLES.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CHAIN": {
            "code": "0x001E",
            "title": "Chain a pair of event counters",
            "description": "For odd-numbered counters, this event increments the count by one for each overflow of the preceding even-numbered counter. For even-numbered counters, there is no increment. This event is used when the even/odd pairs of registers are used as a single counter.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "L2D_CACHE_ALLOCATE": {
            "code": "0x0020",
            "title": "Level 2 data cache allocation without refill",
            "description": "Counts level 2 cache line allocates that do not fetch data from outside the level 2 data or unified cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_RETIRED": {
            "code": "0x0021",
            "title": "Instruction architecturally executed, branch",
            "description": "Counts architecturally executed branches, whether the branch is taken or not. Instructions that explicitly write to the PC are also counted. Note that exception generating instructions, exception return instructions and context synchronization instructions are not counted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BR_MIS_PRED_RETIRED": {
            "code": "0x0022",
            "title": "Branch instruction architecturally executed, mispredicted",
            "description": "Counts branches counted by BR_RETIRED which were mispredicted and caused a pipeline flush.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND": {
            "code": "0x0023",
            "title": "No operation sent for execution due to the frontend",
            "description": "Counts cycles when frontend could not send any micro-operations to the rename stage because of frontend resource stalls caused by fetch memory latency or branch prediction flow stalls. STALL_FRONTEND_SLOTS counts SLOTS during the cycle when this event counts.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND": {
            "code": "0x0024",
            "title": "No operation sent for execution due to the backend",
            "description": "Counts cycles whenever the rename unit is unable to send any micro-operations to the backend of the pipeline because of backend resource constraints. Backend resource constraints can include issue stage fullness, execution stage fullness, or other internal pipeline resource fullness. All the backend slots were empty during the cycle when this event counts.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_TLB": {
            "code": "0x0025",
            "title": "Level 1 data TLB access",
            "description": "Counts level 1 data TLB accesses caused by any memory load or store operation. Note that load or store instructions can be broken up into multiple memory operations. This event does not count TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1I_TLB": {
            "code": "0x0026",
            "title": "Level 1 instruction TLB access",
            "description": "Counts level 1 instruction TLB accesses, whether the access hits or misses in the TLB. This event counts both demand accesses and prefetch or preload generated accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2I_CACHE": {
            "code": "0x0027",
            "title": "Level 2 instruction cache access",
            "description": "Counts accesses to the level 2 cache due to instruction accesses. Level 2 cache is a unified cache for data and instruction accesses. Accesses are for misses in the first level instruction cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2I_CACHE_REFILL": {
            "code": "0x0028",
            "title": "Level 2 instruction cache refill",
            "description": "Counts cache line refills into the level 2 cache. Level 2 cache is a unified cache for data and instruction accesses. Accesses are for misses in the level 1 instruction cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L3D_CACHE_ALLOCATE": {
            "code": "0x0029",
            "title": "Level 3 data cache allocation without refill",
            "description": "Counts level 3 cache line allocates that do not fetch data from outside the level 3 data or unified cache. For example, allocates due to streaming stores.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L3D_CACHE_REFILL": {
            "code": "0x002A",
            "title": "Level 3 data cache refill",
            "description": "Counts level 3 accesses that receive data from outside the L3 cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L3D_CACHE": {
            "code": "0x002B",
            "title": "Level 3 data cache access",
            "description": "Counts level 3 cache accesses. Level 3 cache is a unified cache for data and instruction accesses. Accesses are for misses in the lower level caches or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_TLB_REFILL": {
            "code": "0x002D",
            "title": "Level 2 data TLB refill",
            "description": "Counts level 2 TLB refills caused by memory operations from both data and instruction fetch, except for those caused by TLB maintenance operations and hardware prefetches.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_TLB": {
            "code": "0x002F",
            "title": "Level 2 data TLB access",
            "description": "Counts level 2 TLB accesses except those caused by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "REMOTE_ACCESS": {
            "code": "0x0031",
            "title": "Access to another socket in a multi-socket system",
            "description": "Counts accesses to another chip, which is implemented as a different CMN mesh in the system. If the CHI bus response back to the core indicates that the data source is from another chip (mesh), then the counter is updated. If no data is returned, even if the system snoops another chip/mesh, then the counter is not updated.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LL_CACHE": {
            "code": "0x0032",
            "title": "Last level cache access",
            "description": "Counts transactions that were returned from outside the core cluster. This event counts transactions for external last level cache when the system register CPUECTLR.EXTLLC bit is set, otherwise it counts transactions for L3 cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LL_CACHE_MISS": {
            "code": "0x0033",
            "title": "Last level cache miss",
            "description": "Counts transactions that were returned from outside the core cluster and missed in the last level cache",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "DTLB_WALK": {
            "code": "0x0034",
            "title": "Data TLB access with at least one translation table walk",
            "description": "Counts number of demand data translation table walks caused by a miss in the L2 TLB and performing at least one memory access. Translation table walks are counted even if the translation ended up taking a translation fault for reasons different than EPD, E0PD and NFD. Note that partial translations that cause a translation table walk are also counted. Also note that this event counts walks triggered by software preloads, but not walks triggered by hardware prefetchers, and that this event does not count walks triggered by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ITLB_WALK": {
            "code": "0x0035",
            "title": "Instruction TLB access with at least one translation table walk",
            "description": "Counts number of instruction translation table walks caused by a miss in the L2 TLB and performing at least one memory access. Translation table walks are counted even if the translation ended up taking a translation fault for reasons different than EPD, E0PD and NFD. Note that partial translations that cause a translation table walk are also counted. Also note that this event does not count walks triggered by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LL_CACHE_RD": {
            "code": "0x0036",
            "title": "Last level cache access, read",
            "description": "Counts read transactions that were returned from outside the core cluster. This event counts for external last level cache  when the system register CPUECTLR.EXTLLC bit is set, otherwise it counts for the L3 cache. This event counts read transactions returned from outside the core if those transactions are either hit in the system level cache or missed in the SLC and are returned from any other external sources.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LL_CACHE_MISS_RD": {
            "code": "0x0037",
            "title": "Last level cache miss, read",
            "description": "Counts read transactions that were returned from outside the core cluster but missed in the system level cache. This event counts for external last level cache when the system register CPUECTLR.EXTLLC bit is set, otherwise it counts for L3 cache. This event counts read transactions returned from outside the core if those transactions are missed in the System level Cache. The data source of the transaction is indicated by a field in the CHI transaction returning to the CPU. This event does not count reads caused by cache maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_LMISS_RD": {
            "code": "0x0039",
            "title": "Level 1 data cache long-latency read miss",
            "description": "Counts cache line refills into the level 1 data cache from any memory read operations, that incurred additional latency.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "OP_RETIRED": {
            "code": "0x003A",
            "title": "Micro-operation architecturally executed",
            "description": "Counts micro-operations that are architecturally executed. This is a count of number of micro-operations retired from the commit queue in a single cycle.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "OP_SPEC": {
            "code": "0x003B",
            "title": "Micro-operation speculatively executed",
            "description": "Counts micro-operations speculatively executed. This is the count of the number of micro-operations dispatched in a cycle.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL": {
            "code": "0x003C",
            "title": "No operation sent for execution",
            "description": "Counts cycles when no operations are sent to the rename unit from the frontend or from the rename unit to the backend for any reason (either frontend or backend stall). This event is the sum of STALL_FRONTEND and STALL_BACKEND",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_SLOT_BACKEND": {
            "code": "0x003D",
            "title": "No operation sent for execution on a Slot due to the backend",
            "description": "Counts slots per cycle in which no operations are sent from the rename unit to the backend due to backend resource constraints. STALL_BACKEND counts during the cycle when STALL_SLOT_BACKEND counts at least 1.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_SLOT_FRONTEND": {
            "code": "0x003E",
            "title": "No operation sent for execution on a Slot due to the frontend",
            "description": "Counts slots per cycle in which no operations are sent to the rename unit from the frontend due to frontend resource constraints.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_SLOT": {
            "code": "0x003F",
            "title": "No operation sent for execution on a Slot",
            "description": "Counts slots per cycle in which no operations are sent to the rename unit from the frontend or from the rename unit to the backend for any reason (either frontend or backend stall). STALL_SLOT is the sum of STALL_SLOT_FRONTEND and STALL_SLOT_BACKEND.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_RD": {
            "code": "0x0040",
            "title": "Level 1 data cache access, read",
            "description": "Counts level 1 data cache accesses from any load operation. Atomic load operations that resolve in the CPUs caches counts as both a write access and read access.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L1D_CACHE_WR": {
            "code": "0x0041",
            "title": "Level 1 data cache access, write",
            "description": "Counts level 1 data cache accesses generated by store operations. This event also counts accesses caused by a DC ZVA (data cache zero, specified by virtual address) instruction. Near atomic operations that resolve in the CPUs caches count as a write access and read access.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L1D_CACHE_REFILL_INNER": {
            "code": "0x0044",
            "title": "Level 1 data cache refill, inner",
            "description": "Counts level 1 data cache refills where the cache line data came from caches inside the immediate cluster of the core.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L1D_CACHE_REFILL_OUTER": {
            "code": "0x0045",
            "title": "Level 1 data cache refill, outer",
            "description": "Counts level 1 data cache refills for which the cache line data came from outside the immediate cluster of the core, like an SLC in the system interconnect or DRAM.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L1D_CACHE_INVAL": {
            "code": "0x0048",
            "title": "Level 1 data cache invalidate",
            "description": "Counts each explicit invalidation of a cache line in the level 1 data cache caused by:\n\n- Cache Maintenance Operations (CMO) that operate by a virtual address.\n- Broadcast cache coherency operations from another CPU in the system.\n\nThis event does not count for the following conditions:\n\n1. A cache refill invalidates a cache line.\n2. A CMO which is executed on that CPU and invalidates a cache line specified by set/way.\n\nNote that CMOs that operate by set/way cannot be broadcast from one CPU to another.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_RD": {
            "code": "0x0050",
            "title": "Level 2 data cache access, read",
            "description": "Counts level 2 data cache accesses due to memory read operations. Level 2 cache is a unified cache for data and instruction accesses, accesses are for misses in the level 1 data cache or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_WR": {
            "code": "0x0051",
            "title": "Level 2 data cache access, write",
            "description": "Counts level 2 cache accesses due to memory write operations. Level 2 cache is a unified cache for data and instruction accesses, accesses are for misses in the level 1 data cache or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_REFILL_RD": {
            "code": "0x0052",
            "title": "Level 2 data cache refill, read",
            "description": "Counts refills for memory accesses due to memory read operation counted by L2D_CACHE_RD. Level 2 cache is a unified cache for data and instruction accesses, accesses are for misses in the level 1 data cache or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_REFILL_WR": {
            "code": "0x0053",
            "title": "Level 2 data cache refill, write",
            "description": "Counts refills for memory accesses due to memory write operation counted by L2D_CACHE_WR. Level 2 cache is a unified cache for data and instruction accesses, accesses are for misses in the level 1 data cache or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_WB_VICTIM": {
            "code": "0x0056",
            "title": "Level 2 data cache write-back, victim",
            "description": "Counts evictions from the level 2 cache because of a line being allocated into the L2 cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_WB_CLEAN": {
            "code": "0x0057",
            "title": "Level 2 data cache write-back, cleaning and coherency",
            "description": "Counts write-backs from the level 2 cache that are a result of either:\n\n1. Cache maintenance operations,\n\n2. Snoop responses or,\n\n3. Direct cache transfers to another CPU due to a forwarding snoop request.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L2D_CACHE_INVAL": {
            "code": "0x0058",
            "title": "Level 2 data cache invalidate",
            "description": "Counts each explicit invalidation of a cache line in the level 2 cache by cache maintenance operations that operate by a virtual address, or by external coherency operations. This event does not count if either:\n\n1. A cache refill invalidates a cache line or,\n2. A Cache Maintenance Operation (CMO), which invalidates a cache line specified by set/way, is executed on that CPU.\n\nCMOs that operate by set/way cannot be broadcast from one CPU to another.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "BUS_ACCESS_RD": {
            "code": "0x0060",
            "title": "Bus access, read",
            "description": "Counts memory read transactions seen on the external bus. Each beat of data is counted individually.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "BUS_ACCESS_WR": {
            "code": "0x0061",
            "title": "Bus access, write",
            "description": "Counts memory write transactions seen on the external bus. Each beat of data is counted individually.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "MEM_ACCESS_RD": {
            "code": "0x0066",
            "title": "Data memory access, read",
            "description": "Counts memory accesses issued by the CPU due to load operations. The event counts any memory load access, no matter whether the data is received from any level of cache hierarchy or external memory. The event also counts atomic load operations. If memory accesses are broken up by the load/store unit into smaller transactions that are issued by the bus interface, then the event counts those smaller transactions.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "MEM_ACCESS_WR": {
            "code": "0x0067",
            "title": "Data memory access, write",
            "description": "Counts memory accesses issued by the CPU due to store operations. The event counts any memory store access, no matter whether the data is located in any level of cache or external memory. The event also counts atomic load and store operations. If memory accesses are broken up by the load/store unit into smaller transactions that are issued by the bus interface, then the event counts those smaller transactions.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "STREX_FAIL_SPEC": {
            "code": "0x006E",
            "title": "Exclusive operation speculatively executed, Store-Exclusive fail",
            "description": "Counts store-exclusive operations that have been speculatively executed and have not successfully completed the store operation.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "STREX_SPEC": {
            "code": "0x006F",
            "title": "Exclusive operation speculatively executed, Store-Exclusive",
            "description": "Counts store-exclusive operations that have been speculatively executed.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "LD_SPEC": {
            "code": "0x0070",
            "title": "Operation speculatively executed, load",
            "description": "Counts speculatively executed load operations including Single Instruction Multiple Data (SIMD) load operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "ST_SPEC": {
            "code": "0x0071",
            "title": "Operation speculatively executed, store",
            "description": "Counts speculatively executed store operations including Single Instruction Multiple Data (SIMD) store operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "DP_SPEC": {
            "code": "0x0073",
            "title": "Operation speculatively executed, integer data processing",
            "description": "Counts speculatively executed logical or arithmetic instructions such as MOV/MVN operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "ASE_SPEC": {
            "code": "0x0074",
            "title": "Operation speculatively executed, Advanced SIMD",
            "description": "Counts speculatively executed Advanced SIMD operations excluding load, store and move micro-operations that move data to or from SIMD (vector) registers.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "VFP_SPEC": {
            "code": "0x0075",
            "title": "Operation speculatively executed, scalar floating-point",
            "description": "Counts speculatively executed floating point operations. This event does not count operations that move data to or from floating point (vector) registers.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "PC_WRITE_SPEC": {
            "code": "0x0076",
            "title": "Operation speculatively executed, Software change of the PC",
            "description": "Counts speculatively executed operations which cause software changes of the PC. Those operations include all taken branch operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "CRYPTO_SPEC": {
            "code": "0x0077",
            "title": "Operation speculatively executed, Cryptographic instruction",
            "description": "Counts speculatively executed cryptographic operations except for PMULL and VMULL operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "ISB_SPEC": {
            "code": "0x007C",
            "title": "Barrier speculatively executed, ISB",
            "description": "Counts ISB operations that are executed.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "DSB_SPEC": {
            "code": "0x007D",
            "title": "Barrier speculatively executed, DSB",
            "description": "Counts DSB operations that are speculatively issued to Load/Store unit in the CPU.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "DMB_SPEC": {
            "code": "0x007E",
            "title": "Barrier speculatively executed, DMB",
            "description": "Counts DMB operations that are speculatively issued to the Load/Store unit in the CPU. This event does not count implied barriers from load acquire/store release operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_UNDEF": {
            "code": "0x0081",
            "title": "Exception taken, other synchronous",
            "description": "Counts the number of synchronous exceptions which are taken locally that are due to attempting to execute an instruction that is UNDEFINED. Attempting to execute instruction bit patterns that have not been allocated. Attempting to execute instructions when they are disabled. Attempting to execute instructions at an inappropriate Exception level. Attempting to execute an instruction when the value of PSTATE.IL is 1.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_SVC": {
            "code": "0x0082",
            "title": "Exception taken, Supervisor Call",
            "description": "Counts SVC exceptions taken locally.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_PABORT": {
            "code": "0x0083",
            "title": "Exception taken, Instruction Abort",
            "description": "Counts synchronous exceptions that are taken locally and caused by Instruction Aborts.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_DABORT": {
            "code": "0x0084",
            "title": "Exception taken, Data Abort or SError",
            "description": "Counts exceptions that are taken locally and are caused by data aborts or SErrors. Conditions that could cause those exceptions are attempting to read or write memory where the MMU generates a fault, attempting to read or write memory with a misaligned address, interrupts from the nSEI inputs and internally generated SErrors.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_IRQ": {
            "code": "0x0086",
            "title": "Exception taken, IRQ",
            "description": "Counts IRQ exceptions including the virtual IRQs that are taken locally.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_FIQ": {
            "code": "0x0087",
            "title": "Exception taken, FIQ",
            "description": "Counts FIQ exceptions including the virtual FIQs that are taken locally.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_SMC": {
            "code": "0x0088",
            "title": "Exception taken, Secure Monitor Call",
            "description": "Counts SMC exceptions take to EL3.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_HVC": {
            "code": "0x008A",
            "title": "Exception taken, Hypervisor Call",
            "description": "Counts HVC exceptions taken to EL2.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_TRAP_PABORT": {
            "code": "0x008B",
            "title": "Exception taken, Instruction Abort not Taken locally",
            "description": "Counts exceptions which are traps not taken locally and are caused by Instruction Aborts. For example, attempting to execute an instruction with a misaligned PC.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_TRAP_DABORT": {
            "code": "0x008C",
            "title": "Exception taken, Data Abort or SError not Taken locally",
            "description": "Counts exceptions which are traps not taken locally and are caused by Data Aborts or SError interrupts. Conditions that could cause those exceptions are:\n\n1. Attempting to read or write memory where the MMU generates a fault,\n2. Attempting to read or write memory with a misaligned address,\n3. Interrupts from the SEI input.\n4. internally generated SErrors.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_TRAP_OTHER": {
            "code": "0x008D",
            "title": "Exception taken, other traps not Taken locally",
            "description": "Counts the number of synchronous trap exceptions which are not taken locally and are not SVC, SMC, HVC, data aborts, Instruction Aborts, or interrupts.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_TRAP_IRQ": {
            "code": "0x008E",
            "title": "Exception taken, IRQ not Taken locally",
            "description": "Counts IRQ exceptions including the virtual IRQs that are not taken locally.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "EXC_TRAP_FIQ": {
            "code": "0x008F",
            "title": "Exception taken, FIQ not Taken locally",
            "description": "Counts FIQs which are not taken locally but taken from EL0, EL1,\n or EL2 to EL3 (which would be the normal behavior for FIQs when not executing\n in EL3).",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "RC_LD_SPEC": {
            "code": "0x0090",
            "title": "Release consistency operation speculatively executed, Load-Acquire",
            "description": "Counts any load acquire operations that are speculatively executed. For example: LDAR, LDARH, LDARB",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "RC_ST_SPEC": {
            "code": "0x0091",
            "title": "Release consistency operation speculatively executed, Store-Release",
            "description": "Counts any store release operations that are speculatively executed. For example: STLR, STLRH, STLRB",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "L3D_CACHE_RD": {
            "code": "0x00A0",
            "title": "Level 3 data cache access, read",
            "description": "Counts level 3 cache accesses caused by any memory read operation. Level 3 cache is a unified cache for data and instruction accesses. Accesses are for misses in the lower level caches or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_CT_FLUSH": {
            "code": "0x0120",
            "title": "Flushes including architectural, microarchitectural, and branch redirects",
            "description": "Counts flushes including architectural, microarchitectural, and branch redirects.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_CT_FLUSH_MEM": {
            "code": "0x0121",
            "title": "Flushes due to memory hazards",
            "description": "Counts flushes due to memory hazards.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_CT_FLUSH_BAD_BRANCH": {
            "code": "0x0122",
            "title": "Flushes due to non-branch instruction predicted as a branch",
            "description": "Counts flushes due to non-branch instructions predicted as a branch.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_CT_FLUSH_ISB": {
            "code": "0x0124",
            "title": "Flushes due to ISB or similar side-effects",
            "description": "Counts flushes due to ISB or similar side-effects.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_CT_FLUSH_OTHER": {
            "code": "0x0125",
            "title": "Flushes due to other hazards",
            "description": "Counts flushes due to other hazards.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_LS_RAR": {
            "code": "0x0127",
            "title": "Loadstore detected nuke due to read-after-read ordering hazard",
            "description": "Counts load/store detected nuke due to read-after-read ordering hazard.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_LS_RAW": {
            "code": "0x0128",
            "title": "Loadstore detected nuke due to read-after-write ordering hazard",
            "description": "Counts load/store detected nuke due to read-after-write ordering hazard.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_STALL_BACKEND_RENAME_FRF": {
            "code": "0x0158",
            "title": "RN dispatch stall due to flag registers",
            "description": "Counts backend stalls due to unavailable flag registers.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_STALL_BACKEND_RENAME_GRF": {
            "code": "0x0159",
            "title": "RN dispatch stall due to general registers",
            "description": "Counts backend stalls due to unavailable general registers.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_STALL_BACKEND_RENAME_VRF": {
            "code": "0x015A",
            "title": "RN dispatch stall due to vector registers",
            "description": "Counts backend stalls due to unavailable vector registers.",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true,
            "properties": {
                "debug": true
            }
        },
        "IMP_STALL_BACKEND_IQ_SX": {
            "code": "0x015C",
            "title": "Backend stall cycles, SX IQ full",
            "description": "Counts each cycle counted by STALL_BACKEND_BUSY where the backend is stalled due to the SX IQ being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_STALL_BACKEND_IQ_MX": {
            "code": "0x015D",
            "title": "Backend stall cycles, MX IQ full",
            "description": "Counts each cycle counted by STALL_BACKEND_BUSY where the backend is stalled due to the MX IQ being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_STALL_BACKEND_IQ_LS": {
            "code": "0x015E",
            "title": "Backend stall cycles, LS IQ full",
            "description": "Counts each cycle counted by STALL_BACKEND_BUSY where the backend is stalled due to the LS IQ being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_STALL_BACKEND_IQ_VX": {
            "code": "0x015F",
            "title": "Backend stall cycles, VX IQ full",
            "description": "Counts each cycle counted by STALL_BACKEND_BUSY where the backend is stalled due to the VX IQ being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_STALL_BACKEND_MCQ": {
            "code": "0x0160",
            "title": "Backend stall cycles, MCQ full",
            "description": "Counts each cycle counted by STALL_BACKEND_CPUBOUND where the backend is stalled due to the MCQ being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_L2_CHI_CBUSY0": {
            "code": "0x0198",
            "title": "Number of RXDAT or RXRSP response received with CBusy of 0",
            "description": "Count of RXDAT or RXRSP responses received with indication completer fullness indicator set to 0",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_L2_CHI_CBUSY1": {
            "code": "0x0199",
            "title": "Number of RXDAT or RXRSP response received with CBusy of 1",
            "description": "Count of RXDAT or RXRSP responses received with indication completer fullness indicator set to 1",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_L2_CHI_CBUSY2": {
            "code": "0x019A",
            "title": "Number of RXDAT or RXRSP response received with CBusy of 2",
            "description": "Count of RXDAT or RXRSP responses received with indication completer fullness indicator set to 2",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_L2_CHI_CBUSY3": {
            "code": "0x019B",
            "title": "Number of RXDAT or RXRSP response received with CBusy of 3",
            "description": "Count of RXDAT or RXRSP responses received with indication completer fullness indicator set to 3",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_L2_CHI_CBUSY_MT": {
            "code": "0x019C",
            "title": "Number of RXDAT or RXRSP response received with CBusy Multi-threaded set",
            "description": "Count of RXDAT or RXRSP responses received with indication completer indicating multiple cores actively making requests",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_STALL_BACKEND_PCRF": {
            "code": "0x1003",
            "title": "Backend stall cycles, PCRF full",
            "description": "Counts each cycle counted by STALL_BACKEND_CPUBOUND where the backend is stalled due to the PCRF being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "IMP_STALL_BACKEND_RSTACK": {
            "code": "0x1005",
            "title": "Backend stall cycles, return stack full",
            "description": "Counts each cycle counted by STALL_BACKEND_CPUBOUND where the backend is stalled due to the return stack being full",
            "common": false,
            "accesses": [
                "PMU"
            ],
            "architectural": false,
            "impdef": true
        },
        "SAMPLE_POP": {
            "code": "0x4000",
            "title": "Statistical Profiling sample population",
            "description": "Counts statistical profiling sample population, the count of all operations that could be sampled but may or may not be chosen for sampling.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED": {
            "code": "0x4001",
            "title": "Statistical Profiling sample taken",
            "description": "Counts statistical profiling samples taken for sampling.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FILTRATE": {
            "code": "0x4002",
            "title": "Statistical Profiling sample taken and not removed by filtering",
            "description": "Counts statistical profiling samples taken which are not removed by filtering.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_COLLISION": {
            "code": "0x4003",
            "title": "Statistical Profiling sample collided with previous sample",
            "description": "Counts statistical profiling samples that have collided with a previous sample and so therefore not taken.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CNT_CYCLES": {
            "code": "0x4004",
            "title": "Constant frequency cycles",
            "description": "Increments at a constant frequency equal to the rate of increment of the System Counter, CNTPCT_EL0.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_MEM": {
            "code": "0x4005",
            "title": "Memory stall cycles",
            "description": "Counts cycles when the backend is stalled because there is a pending demand load request in progress in the last level core cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1I_CACHE_LMISS": {
            "code": "0x4006",
            "title": "Level 1 instruction cache long-latency miss",
            "description": "Counts cache line refills into the level 1 instruction cache, that incurred additional latency.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE_LMISS_RD": {
            "code": "0x4009",
            "title": "Level 2 data cache long-latency read miss",
            "description": "Counts cache line refills into the level 2 unified cache from any memory read operations that incurred additional latency.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2I_CACHE_LMISS": {
            "code": "0x400A",
            "title": "Level 2 instruction cache long-latency miss",
            "description": "Counts cache line refills into the level 2 unified cache from any instruction read operations that incurred additional latency.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L3D_CACHE_LMISS_RD": {
            "code": "0x400B",
            "title": "Level 3 data cache long-latency read miss",
            "description": "Counts any cache line refill into the level 3 cache from memory read operations that incurred additional latency.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "TRB_WRAP": {
            "code": "0x400C",
            "title": "Trace buffer current write pointer wrapped",
            "description": "This event is generated each time the current write pointer is wrapped to the base pointer.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "PMU_OVFS": {
            "code": "0x400D",
            "title": "PMU overflow, counters accessible to EL1 and EL0",
            "description": "This event is generated each time an event causes a PMEVCTNR&lt;n&gt;_EL1 counter overflow when PMINTENSET_EL1[n] is set to 1, for each implemented PMU counter n in the range 0 <= n < UInt(MDCR_EL2.HPMN), and the Cycle Counter (n = 31).",
            "common": true,
            "accesses": [
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "TRB_TRIG": {
            "code": "0x400E",
            "title": "Trace buffer Trigger Event",
            "description": "This event is generated when a Trace Buffer Extension Trigger Event occurs.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "PMU_HOVFS": {
            "code": "0x400F",
            "title": "PMU overflow, counters reserved for use by EL2",
            "description": "This event is generated each time an event causes a PMEVCTNR&lt;n&gt;_EL1 counter overflow when PMINTENSET_EL1[n] is set to 1, for each implemented PMU counter n in the range UInt(MDCR_EL2.HPMN) <= n < UInt(PMCR_EL0.N). This event is not transmitted to a PE Trace Unit while TRCFR_EL2.E2TRE == 0b0.",
            "common": true,
            "accesses": [
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "TRCEXTOUT0": {
            "code": "0x4010",
            "title": "Trace unit external output 0",
            "description": "This event is generated each time an event is signaled by ETE external event 0.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "TRCEXTOUT1": {
            "code": "0x4011",
            "title": "Trace unit external output 1",
            "description": "This event is generated each time an event is signaled by ETE external event 1.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "TRCEXTOUT2": {
            "code": "0x4012",
            "title": "Trace unit external output 2",
            "description": "This event is generated each time an event is signaled by ETE external event 2.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "TRCEXTOUT3": {
            "code": "0x4013",
            "title": "Trace unit external output 3",
            "description": "This event is generated each time an event is signaled by ETE external event 3.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CTI_TRIGOUT4": {
            "code": "0x4018",
            "title": "Cross-trigger Interface output trigger 4",
            "description": "This event is generated each time an event is signaled on CTI output trigger 4.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CTI_TRIGOUT5": {
            "code": "0x4019",
            "title": "Cross-trigger Interface output trigger 5",
            "description": "This event is generated each time an event is signaled on CTI output trigger 5.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CTI_TRIGOUT6": {
            "code": "0x401A",
            "title": "Cross-trigger Interface output trigger 6",
            "description": "This event is generated each time an event is signaled on CTI output trigger 6.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CTI_TRIGOUT7": {
            "code": "0x401B",
            "title": "Cross-trigger Interface output trigger 7",
            "description": "This event is generated each time an event is signaled on CTI output trigger 7.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LDST_ALIGN_LAT": {
            "code": "0x4020",
            "title": "Access with additional latency from alignment",
            "description": "Counts the number of memory read and write accesses in a cycle that incurred additional latency, due to the alignment of the address and the size of data being accessed, which results in store crossing a single cache line.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LD_ALIGN_LAT": {
            "code": "0x4021",
            "title": "Load with additional latency from alignment",
            "description": "Counts the number of memory read accesses in a cycle that incurred additional latency, due to the alignment of the address and size of data being accessed, which results in load crossing a single cache line.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ST_ALIGN_LAT": {
            "code": "0x4022",
            "title": "Store with additional latency from alignment",
            "description": "Counts the number of memory write access in a cycle that incurred additional latency, due to the alignment of the address and size of data being accessed incurred additional latency.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "MEM_ACCESS_CHECKED": {
            "code": "0x4024",
            "title": "Checked data memory access",
            "description": "Counts the number of memory read and write accesses counted by MEM_ACCESS that are tag checked by the Memory Tagging Extension (MTE). This event is implemented as the sum of MEM_ACCESS_CHECKED_RD and MEM_ACCESS_CHECKED_WR",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "MEM_ACCESS_CHECKED_RD": {
            "code": "0x4025",
            "title": "Checked data memory access, read",
            "description": "Counts the number of memory read accesses in a cycle that are tag checked by the Memory Tagging Extension (MTE).",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "MEM_ACCESS_CHECKED_WR": {
            "code": "0x4026",
            "title": "Checked data memory access, write",
            "description": "Counts the number of memory write accesses in a cycle that is tag checked by the Memory Tagging Extension (MTE).",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ASE_INST_SPEC": {
            "code": "0x8005",
            "title": "Operation speculatively executed, Advanced SIMD",
            "description": "Counts speculatively executed Advanced SIMD operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_INST_SPEC": {
            "code": "0x8006",
            "title": "Operation speculatively executed, SVE, including load and store",
            "description": "Counts speculatively executed operations that are SVE operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "FP_HP_SPEC": {
            "code": "0x8014",
            "title": "Floating-point operation speculatively executed, half precision",
            "description": "Counts speculatively executed half precision floating point operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "FP_SP_SPEC": {
            "code": "0x8018",
            "title": "Floating-point operation speculatively executed, single precision",
            "description": "Counts speculatively executed single precision floating point operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "FP_DP_SPEC": {
            "code": "0x801C",
            "title": "Floating-point operation speculatively executed, double precision",
            "description": "Counts speculatively executed double precision floating point operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_PRED_SPEC": {
            "code": "0x8074",
            "title": "Operation speculatively executed, SVE predicated",
            "description": "Counts speculatively executed predicated SVE operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_PRED_EMPTY_SPEC": {
            "code": "0x8075",
            "title": "Operation speculatively executed, SVE predicated with no active predicates",
            "description": "Counts speculatively executed predicated SVE operations with no active predicate elements.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_PRED_FULL_SPEC": {
            "code": "0x8076",
            "title": "Operation speculatively executed, SVE predicated with all active predicates",
            "description": "Counts speculatively executed predicated SVE operations with all predicate elements active.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_PRED_PARTIAL_SPEC": {
            "code": "0x8077",
            "title": "Operation speculatively executed, SVE predicated with partially active predicates",
            "description": "Counts speculatively executed predicated SVE operations with at least one but not all active predicate elements.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_PRED_NOT_FULL_SPEC": {
            "code": "0x8079",
            "title": "SVE predicated operations speculatively executed with no active or partially active predicates",
            "description": "Counts speculatively executed predicated SVE operations with at least one non active predicate elements.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_LDFF_SPEC": {
            "code": "0x80BC",
            "title": "Operation speculatively executed, SVE first-fault load",
            "description": "Counts speculatively executed SVE first fault or non-fault load operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SVE_LDFF_FAULT_SPEC": {
            "code": "0x80BD",
            "title": "Operation speculatively executed, SVE first-fault load which set FFR bit to 0b0",
            "description": "Counts speculatively executed SVE first fault or non-fault load operations that clear at least one bit in the FFR.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "FP_SCALE_OPS_SPEC": {
            "code": "0x80C0",
            "title": "Scalable floating-point element ALU operations speculatively executed",
            "description": "Counts speculatively executed scalable single precision floating point operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "FP_FIXED_OPS_SPEC": {
            "code": "0x80C1",
            "title": "Non-scalable floating-point element ALU operations speculatively executed",
            "description": "Counts speculatively executed non-scalable single precision floating point operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ASE_SVE_INT8_SPEC": {
            "code": "0x80E3",
            "title": "Integer operation speculatively executed, Advanced SIMD or SVE 8-bit",
            "description": "Counts speculatively executed Advanced SIMD or SVE integer operations with the largest data type an 8-bit integer.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ASE_SVE_INT16_SPEC": {
            "code": "0x80E7",
            "title": "Integer operation speculatively executed, Advanced SIMD or SVE 16-bit",
            "description": "Counts speculatively executed Advanced SIMD or SVE integer operations with the largest data type a 16-bit integer.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ASE_SVE_INT32_SPEC": {
            "code": "0x80EB",
            "title": "Integer operation speculatively executed, Advanced SIMD or SVE 32-bit",
            "description": "Counts speculatively executed Advanced SIMD or SVE integer operations with the largest data type a 32-bit integer.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ASE_SVE_INT64_SPEC": {
            "code": "0x80EF",
            "title": "Integer operation speculatively executed, Advanced SIMD or SVE 64-bit",
            "description": "Counts speculatively executed Advanced SIMD or SVE integer operations with the largest data type a 64-bit integer.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_IMMED_TAKEN_RETIRED": {
            "code": "0x8108",
            "title": "Branch instruction architecturally executed, immediate, taken",
            "description": "Counts architecturally executed direct branches that were taken.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BR_INDNR_TAKEN_RETIRED": {
            "code": "0x810C",
            "title": "Branch instruction architecturally executed, indirect excluding procedure return, taken",
            "description": "Counts architecturally executed indirect branches excluding procedure returns that were taken.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "BR_IMMED_PRED_RETIRED": {
            "code": "0x8110",
            "title": "Branch instruction architecturally executed, predicted immediate",
            "description": "Counts architecturally executed direct branches that were correctly predicted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_IMMED_MIS_PRED_RETIRED": {
            "code": "0x8111",
            "title": "Branch instruction architecturally executed, mispredicted immediate",
            "description": "Counts architecturally executed direct branches that were mispredicted and caused a pipeline flush.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_IND_PRED_RETIRED": {
            "code": "0x8112",
            "title": "Branch instruction architecturally executed, predicted indirect",
            "description": "Counts architecturally executed indirect branches including procedure returns that were correctly predicted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_IND_MIS_PRED_RETIRED": {
            "code": "0x8113",
            "title": "Branch instruction architecturally executed, mispredicted indirect",
            "description": "Counts architecturally executed indirect branches including procedure returns that were mispredicted and caused a pipeline flush.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_RETURN_PRED_RETIRED": {
            "code": "0x8114",
            "title": "Branch instruction architecturally executed, predicted procedure return",
            "description": "Counts architecturally executed procedure returns that were correctly predicted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_RETURN_MIS_PRED_RETIRED": {
            "code": "0x8115",
            "title": "Branch instruction architecturally executed, mispredicted procedure return",
            "description": "Counts architecturally executed procedure returns that were mispredicted and caused a pipeline flush.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_INDNR_PRED_RETIRED": {
            "code": "0x8116",
            "title": "Branch instruction architecturally executed, predicted indirect excluding procedure return",
            "description": "Counts architecturally executed indirect branches excluding procedure returns that were correctly predicted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_INDNR_MIS_PRED_RETIRED": {
            "code": "0x8117",
            "title": "Branch instruction architecturally executed, mispredicted indirect excluding procedure return",
            "description": "Counts architecturally executed indirect branches excluding procedure returns that were mispredicted and caused a pipeline flush.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_PRED_RETIRED": {
            "code": "0x811C",
            "title": "Branch instruction architecturally executed, predicted branch",
            "description": "Counts branch instructions counted by BR_RETIRED which were correctly predicted.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "BR_IND_RETIRED": {
            "code": "0x811D",
            "title": "Instruction architecturally executed, indirect branch",
            "description": "Counts architecturally executed indirect branches including procedure returns.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": true,
            "impdef": false
        },
        "INST_FETCH_PERCYC": {
            "code": "0x8120",
            "title": "Event in progress, INST FETCH",
            "description": "Counts number of instruction fetches outstanding per cycle, which will provide an average latency of instruction fetch.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "MEM_ACCESS_RD_PERCYC": {
            "code": "0x8121",
            "title": "Event in progress, MEM ACCESS RD",
            "description": "Counts the number of outstanding loads or memory read accesses per cycle.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "INST_FETCH": {
            "code": "0x8124",
            "title": "Instruction memory access",
            "description": "Counts Instruction memory accesses that the PE makes.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "DTLB_WALK_PERCYC": {
            "code": "0x8128",
            "title": "Event in progress, DTLB WALK",
            "description": "Counts the number of data translation table walks in progress per cycle.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ITLB_WALK_PERCYC": {
            "code": "0x8129",
            "title": "Event in progress, ITLB WALK",
            "description": "Counts the number of instruction translation table walks in progress per cycle.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED_BR": {
            "code": "0x812A",
            "title": "Statisical Profiling sample taken, branch",
            "description": "Counts statistical profiling samples taken which are branches.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED_LD": {
            "code": "0x812B",
            "title": "Statisical Profiling sample taken, load",
            "description": "Counts statistical profiling samples taken which are loads or load atomic operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED_ST": {
            "code": "0x812C",
            "title": "Statisical Profiling sample taken, store",
            "description": "Counts statistical profiling samples taken which are stores or store atomic operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED_OP": {
            "code": "0x812D",
            "title": "Statisical Profiling sample taken, matching operation type",
            "description": "Counts statistical profiling samples taken which are matching any operation type filters supported.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED_EVENT": {
            "code": "0x812E",
            "title": "Statisical Profiling sample taken, matching events",
            "description": "Counts statistical profiling samples taken which are matching event packet filter constraints.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "SAMPLE_FEED_LAT": {
            "code": "0x812F",
            "title": "Statisical Profiling sample taken, exceeding minimum latency",
            "description": "Counts statistical profiling samples taken which are exceeding minimum latency set by operation latency filter constraints.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "DTLB_HWUPD": {
            "code": "0x8134",
            "title": "Data TLB hardware update of translation table",
            "description": "Counts number of memory accesses triggered by a data translation table walk and performing an update of a translation table entry. Memory accesses are counted even if the translation ended up taking a translation fault for reasons different than EPD, E0PD and NFD. Note that this event counts accesses triggered by software preloads, but not accesses triggered by hardware prefetchers.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ITLB_HWUPD": {
            "code": "0x8135",
            "title": "Instruction TLB hardware update of translation table",
            "description": "Counts number of memory accesses triggered by an instruction translation table walk and performing an update of a translation table entry. Memory accesses are counted even if the translation ended up taking a translation fault for reasons different than EPD, E0PD and NFD.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "DTLB_STEP": {
            "code": "0x8136",
            "title": "Data TLB translation table walk, step",
            "description": "Counts number of memory accesses triggered by a demand data translation table walk and performing a read of a translation table entry. Memory accesses are counted even if the translation ended up taking a translation fault for reasons different than EPD, E0PD and NFD. Note that this event counts accesses triggered by software preloads, but not accesses triggered by hardware prefetchers.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ITLB_STEP": {
            "code": "0x8137",
            "title": "Instruction TLB translation table walk, step",
            "description": "Counts number of memory accesses triggered by an instruction translation table walk and performing a read of a translation table entry. Memory accesses are counted even if the translation ended up taking a translation fault for reasons different than EPD, E0PD and NFD.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "DTLB_WALK_LARGE": {
            "code": "0x8138",
            "title": "Data TLB large page translation table walk",
            "description": "Counts number of demand data translation table walks caused by a miss in the L2 TLB and yielding a large page. The set of large pages is defined as all pages with a final size higher than or equal to 2MB. Translation table walks that end up taking a translation fault are not counted, as the page size would be undefined in that case. If DTLB_WALK_BLOCK is implemented, then it is an alias for this event in this family. Note that partial translations that cause a translation table walk are also counted. Also note that this event counts walks triggered by software preloads, but not walks triggered by hardware prefetchers, and that this event does not count walks triggered by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ITLB_WALK_LARGE": {
            "code": "0x8139",
            "title": "Instruction TLB large page translation table walk",
            "description": "Counts number of instruction translation table walks caused by a miss in the L2 TLB and yielding a large page. The set of large pages is defined as all pages with a final size higher than or equal to 2MB. Translation table walks that end up taking a translation fault are not counted, as the page size would be undefined in that case. In this family, this is equal to ITLB_WALK_BLOCK event. Note that partial translations that cause a translation table walk are also counted. Also note that this event does not count walks triggered by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "DTLB_WALK_SMALL": {
            "code": "0x813A",
            "title": "Data TLB small page translation table walk",
            "description": "Counts number of data translation table walks caused by a miss in the L2 TLB and yielding a small page. The set of small pages is defined as all pages with a final size lower than 2MB. Translation table walks that end up taking a translation fault are not counted, as the page size would be undefined in that case. If DTLB_WALK_PAGE event is implemented, then it is an alias for this event in this family. Note that partial translations that cause a translation table walk are also counted. Also note that this event counts walks triggered by software preloads, but not walks triggered by hardware prefetchers, and that this event does not count walks triggered by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "ITLB_WALK_SMALL": {
            "code": "0x813B",
            "title": "Instruction TLB small page translation table walk",
            "description": "Counts number of instruction translation table walks caused by a miss in the L2 TLB and yielding a small page. The set of small pages is defined as all pages with a final size lower than 2MB. Translation table walks that end up taking a translation fault are not counted, as the page size would be undefined in that case. In this family, this is equal to ITLB_WALK_PAGE event. Note that partial translations that cause a translation table walk are also counted. Also note that this event does not count walks triggered by TLB maintenance operations.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_RW": {
            "code": "0x8140",
            "title": "Level 1 data cache demand access",
            "description": "Counts level 1 data demand cache accesses from any load or store operation. Near atomic operations that resolve in the CPUs caches counts as both a write access and read access.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE_RW": {
            "code": "0x8148",
            "title": "Level 2 data cache demand access",
            "description": "Counts level 2 cache demand accesses from any load/store operations. Level 2 cache is a unified cache for data and instruction accesses, accesses are for misses in the level 1 data cache or translation resolutions due to accesses.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2I_CACHE_RD": {
            "code": "0x8149",
            "title": "Level 2 instruction cache demand fetch",
            "description": "Counts level 2 cache accesses that are due to a demand instruction cache access.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L3D_CACHE_MISS": {
            "code": "0x8152",
            "title": "Level 3 data cache demand access miss",
            "description": "Counts level 3 cache accesses that missed in the level 3 cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_HWPRF": {
            "code": "0x8154",
            "title": "Level 1 data cache hardware prefetch",
            "description": "Counts level 1 data cache accesses from any load/store operations generated by the hardware prefetcher.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_MEMBOUND": {
            "code": "0x8158",
            "title": "Frontend stall cycles, memory bound",
            "description": "Counts cycles when the frontend could not send any micro-operations to the rename stage due to resource constraints in the memory resources.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_L1I": {
            "code": "0x8159",
            "title": "Frontend stall cycles, level 1 instruction cache",
            "description": "Counts cycles when the frontend is stalled because there is an instruction fetch request pending in the level 1 instruction cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_MEM": {
            "code": "0x815B",
            "title": "Frontend stall cycles, last level PE cache or memory",
            "description": "Counts cycles when the frontend is stalled because there is an instruction fetch request pending in the last level core cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_TLB": {
            "code": "0x815C",
            "title": "Frontend stall cycles, TLB",
            "description": "Counts when the frontend is stalled on any TLB misses being handled. This event also counts the TLB accesses made by hardware prefetches.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_CPUBOUND": {
            "code": "0x8160",
            "title": "Frontend stall cycles, processor bound",
            "description": "Counts cycles when the frontend could not send any micro-operations to the rename stage due to resource constraints in the CPU resources excluding memory resources.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_FLOW": {
            "code": "0x8161",
            "title": "Frontend stall cycles, flow control",
            "description": "Counts cycles when the frontend could not send any micro-operations to the rename stage due to resource constraints in the branch prediction unit.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_FRONTEND_FLUSH": {
            "code": "0x8162",
            "title": "Frontend stall cycles, flush recovery",
            "description": "Counts cycles when the frontend could not send any micro-operations to the rename stage as the frontend is recovering from a machine flush or resteer. Example scenarios that cause a flush include branch mispredictions, taken exceptions, micro-architectural flush etc.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_MEMBOUND": {
            "code": "0x8164",
            "title": "Backend stall cycles, memory bound",
            "description": "Counts cycles when the backend could not accept any micro-operations due to resource constraints in the memory resources.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_L1D": {
            "code": "0x8165",
            "title": "Backend stall cycles, level 1 data cache",
            "description": "Counts cycles when the backend is stalled because there is a pending demand load request in progress in the level 1 data cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_TLB": {
            "code": "0x8167",
            "title": "Backend stall cycles, TLB",
            "description": "Counts cycles when the backend is stalled on any demand TLB misses being handled.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_ST": {
            "code": "0x8168",
            "title": "Backend stall cycles, store",
            "description": "Counts cycles when the backend is stalled and there is a store that has not reached the pre-commit stage.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_CPUBOUND": {
            "code": "0x816A",
            "title": "Backend stall cycles, processor bound",
            "description": "Counts cycles when the backend could not accept any micro-operations due to any resource constraints in the CPU excluding memory resources.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_BUSY": {
            "code": "0x816B",
            "title": "Backend stall cycles, backend busy",
            "description": "Counts cycles when the backend could not accept any micro-operations because the issue queues are full to take any operations for execution.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "STALL_BACKEND_RENAME": {
            "code": "0x816D",
            "title": "Backend stall cycles, rename full",
            "description": "Counts cycles when backend is stalled even when operations are available from the frontend but at least one is not ready to be sent to the backend because no rename register is available.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CAS_NEAR_PASS": {
            "code": "0x8171",
            "title": "Atomic memory Operation speculatively executed, Compare and Swap pass",
            "description": "Counts compare and swap instructions that executed locally to the PE and updated the location accessed.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CAS_NEAR_SPEC": {
            "code": "0x8172",
            "title": "Atomic memory Operation speculatively executed, Compare and Swap near",
            "description": "Counts compare and swap instructions that executed locally to the PE.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "CAS_FAR_SPEC": {
            "code": "0x8173",
            "title": "Atomic memory Operation speculatively executed, Compare and Swap far",
            "description": "Counts compare and swap instructions that did not execute locally to the PE.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L1D_CACHE_REFILL_HWPRF": {
            "code": "0x81BC",
            "title": "Level 1 data cache refill, hardware prefetch",
            "description": "Counts level 1 data cache refills where the cache line is requested by a hardware prefetcher.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE_PRF": {
            "code": "0x8285",
            "title": "Level 2 data cache, preload or prefetch hit",
            "description": "Counts level 2 data cache accesses from software preload or prefetch instructions or hardware prefetcher.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "L2D_CACHE_REFILL_PRF": {
            "code": "0x828D",
            "title": "Level 2 data cache refill, preload or prefetch hit",
            "description": "Counts refills due to accesses generated as a result of prefetches.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        },
        "LL_CACHE_REFILL": {
            "code": "0x829A",
            "title": "Last level cache refill",
            "description": "Counts last level accesses that receive data from outside the last level cache.",
            "common": true,
            "accesses": [
                "PMU",
                "ETE"
            ],
            "architectural": false,
            "impdef": false
        }
    },
    "metrics": {
        "backend_bound": {
            "title": "Backend Bound",
            "formula": "STALL_SLOT_BACKEND / (5 * CPU_CYCLES) * 100",
            "description": "This metric is the percentage of total slots that were stalled due to resource constraints in the backend of the processor.",
            "units": "percent of slots",
            "events": [
                "CPU_CYCLES",
                "STALL_SLOT_BACKEND"
            ],
            "sample_events": [
                "STALL_SLOT_BACKEND"
            ]
        },
        "backend_busy_bound": {
            "title": "Backend Busy Bound",
            "formula": "STALL_BACKEND_BUSY / STALL_BACKEND * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to issue queues being full to accept operations for execution.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND",
                "STALL_BACKEND_BUSY"
            ],
            "sample_events": [
                "STALL_BACKEND_BUSY"
            ]
        },
        "backend_cache_l1d_bound": {
            "title": "Backend Cache L1D Bound",
            "formula": "STALL_BACKEND_L1D / (STALL_BACKEND_L1D + STALL_BACKEND_MEM) * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to memory access latency issues caused by level 1 data cache misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND_L1D",
                "STALL_BACKEND_MEM"
            ],
            "sample_events": [
                "STALL_BACKEND_L1D"
            ]
        },
        "backend_cache_l2d_bound": {
            "title": "Backend Cache L2D Bound",
            "formula": "STALL_BACKEND_MEM / (STALL_BACKEND_L1D + STALL_BACKEND_MEM) * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to memory access latency issues caused by level 2 data cache misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND_L1D",
                "STALL_BACKEND_MEM"
            ],
            "sample_events": [
                "STALL_BACKEND_MEM"
            ]
        },
        "backend_core_bound": {
            "title": "Backend Core Bound",
            "formula": "STALL_BACKEND_CPUBOUND / STALL_BACKEND * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to backend core resource constraints not related to instruction fetch latency issues caused by memory access components.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND",
                "STALL_BACKEND_CPUBOUND"
            ],
            "sample_events": [
                "STALL_BACKEND_CPUBOUND"
            ]
        },
        "backend_core_rename_bound": {
            "title": "Backend Core Rename Bound",
            "formula": "STALL_BACKEND_RENAME / STALL_BACKEND_CPUBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend as the rename unit registers are unavailable.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND_CPUBOUND",
                "STALL_BACKEND_RENAME"
            ],
            "sample_events": [
                "STALL_BACKEND_RENAME"
            ]
        },
        "backend_mem_bound": {
            "title": "Backend Memory Bound",
            "formula": "STALL_BACKEND_MEMBOUND / STALL_BACKEND * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to backend core resource constraints related to memory access latency issues caused by memory access components.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND",
                "STALL_BACKEND_MEMBOUND"
            ],
            "sample_events": [
                "STALL_BACKEND_MEMBOUND"
            ]
        },
        "backend_mem_cache_bound": {
            "title": "Backend Memory Cache Bound",
            "formula": "(STALL_BACKEND_L1D + STALL_BACKEND_MEM) / STALL_BACKEND_MEMBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to memory latency issues caused by data cache misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND_L1D",
                "STALL_BACKEND_MEM",
                "STALL_BACKEND_MEMBOUND"
            ],
            "sample_events": [
                "STALL_BACKEND_MEM",
                "STALL_BACKEND_L1D"
            ]
        },
        "backend_mem_store_bound": {
            "title": "Backend Memory Store Bound",
            "formula": "STALL_BACKEND_ST / STALL_BACKEND_MEMBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to memory write pending caused by stores stalled in the pre-commit stage.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND_MEMBOUND",
                "STALL_BACKEND_ST"
            ],
            "sample_events": [
                "STALL_BACKEND_ST"
            ]
        },
        "backend_mem_tlb_bound": {
            "title": "Backend Memory TLB Bound",
            "formula": "STALL_BACKEND_TLB / STALL_BACKEND_MEMBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the backend due to memory access latency issues caused by data TLB misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_BACKEND_MEMBOUND",
                "STALL_BACKEND_TLB"
            ],
            "sample_events": [
                "STALL_BACKEND_TLB"
            ]
        },
        "backend_stalled_cycles": {
            "title": "Backend Stalled Cycles",
            "formula": "STALL_BACKEND / CPU_CYCLES * 100",
            "description": "This metric is the percentage of cycles that were stalled due to resource constraints in the backend unit of the processor.",
            "units": "percent of cycles",
            "events": [
                "CPU_CYCLES",
                "STALL_BACKEND"
            ],
            "sample_events": [
                "STALL_BACKEND"
            ]
        },
        "bad_speculation": {
            "title": "Bad Speculation",
            "formula": "(1 - STALL_SLOT / (5 * CPU_CYCLES)) * (1 - OP_RETIRED / OP_SPEC) * 100 + STALL_FRONTEND_FLUSH / CPU_CYCLES * 100",
            "description": "This metric is the percentage of total slots that executed operations and didn't retire due to a pipeline flush.\nThis indicates cycles that were utilized but inefficiently.",
            "units": "percent of slots",
            "events": [
                "CPU_CYCLES",
                "OP_RETIRED",
                "OP_SPEC",
                "STALL_FRONTEND_FLUSH",
                "STALL_SLOT"
            ],
            "sample_events": [
                "STALL_FRONTEND_FLUSH"
            ]
        },
        "barrier_percentage": {
            "title": "Barrier Operations Percentage",
            "formula": "(ISB_SPEC + DSB_SPEC + DMB_SPEC) / INST_SPEC * 100",
            "description": "This metric measures instruction and data barrier operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "DMB_SPEC",
                "DSB_SPEC",
                "INST_SPEC",
                "ISB_SPEC"
            ],
            "sample_events": [
                "ISB_SPEC",
                "DSB_SPEC",
                "DMB_SPEC"
            ]
        },
        "branch_direct_ratio": {
            "title": "Branch Direct Ratio",
            "formula": "BR_IMMED_RETIRED / BR_RETIRED",
            "description": "This metric measures the ratio of direct branches retired to the total number of branches architecturally executed.",
            "units": "per branch",
            "events": [
                "BR_IMMED_RETIRED",
                "BR_RETIRED"
            ],
            "sample_events": [
                "BR_IMMED_RETIRED"
            ]
        },
        "branch_indirect_ratio": {
            "title": "Branch Indirect Ratio",
            "formula": "BR_IND_RETIRED / BR_RETIRED",
            "description": "This metric measures the ratio of indirect branches retired, including function returns, to the total number of branches architecturally executed.",
            "units": "per branch",
            "events": [
                "BR_IND_RETIRED",
                "BR_RETIRED"
            ],
            "sample_events": [
                "BR_IND_RETIRED"
            ]
        },
        "branch_misprediction_ratio": {
            "title": "Branch Misprediction Ratio",
            "formula": "BR_MIS_PRED_RETIRED / BR_RETIRED",
            "description": "This metric measures the ratio of branches mispredicted to the total number of branches architecturally executed. This gives an indication of the effectiveness of the branch prediction unit.",
            "units": "per branch",
            "events": [
                "BR_MIS_PRED_RETIRED",
                "BR_RETIRED"
            ],
            "sample_events": [
                "BR_MIS_PRED_RETIRED"
            ]
        },
        "branch_mpki": {
            "title": "Branch MPKI",
            "formula": "BR_MIS_PRED_RETIRED / INST_RETIRED * 1000",
            "description": "This metric measures the number of branch mispredictions per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "BR_MIS_PRED_RETIRED",
                "INST_RETIRED"
            ],
            "sample_events": [
                "BR_MIS_PRED_RETIRED"
            ]
        },
        "branch_percentage": {
            "title": "Branch Operations Percentage",
            "formula": "PC_WRITE_SPEC / INST_SPEC * 100",
            "description": "This metric measures branch operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "INST_SPEC",
                "PC_WRITE_SPEC"
            ],
            "sample_events": [
                "PC_WRITE_SPEC"
            ]
        },
        "branch_return_ratio": {
            "title": "Branch Return Ratio",
            "formula": "BR_RETURN_RETIRED / BR_RETIRED",
            "description": "This metric measures the ratio of branches retired that are function returns to the total number of branches architecturally executed.",
            "units": "per branch",
            "events": [
                "BR_RETIRED",
                "BR_RETURN_RETIRED"
            ],
            "sample_events": [
                "BR_RETURN_RETIRED"
            ]
        },
        "crypto_percentage": {
            "title": "Crypto Operations Percentage",
            "formula": "CRYPTO_SPEC / INST_SPEC * 100",
            "description": "This metric measures crypto operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "CRYPTO_SPEC",
                "INST_SPEC"
            ],
            "sample_events": [
                "CRYPTO_SPEC"
            ]
        },
        "dtlb_mpki": {
            "title": "DTLB MPKI",
            "formula": "DTLB_WALK / INST_RETIRED * 1000",
            "description": "This metric measures the number of data TLB Walks per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "DTLB_WALK",
                "INST_RETIRED"
            ],
            "sample_events": [
                "DTLB_WALK"
            ]
        },
        "dtlb_walk_ratio": {
            "title": "DTLB Walk Ratio",
            "formula": "DTLB_WALK / L1D_TLB",
            "description": "This metric measures the ratio of data TLB Walks to the total number of data TLB accesses. This gives an indication of the effectiveness of the data TLB accesses.",
            "units": "per TLB access",
            "events": [
                "DTLB_WALK",
                "L1D_TLB"
            ],
            "sample_events": [
                "DTLB_WALK"
            ]
        },
        "fp16_percentage": {
            "title": "Half Precision Floating Point Percentage",
            "formula": "FP_HP_SPEC / INST_SPEC * 100",
            "description": "This metric measures half-precision floating point operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "FP_HP_SPEC",
                "INST_SPEC"
            ],
            "sample_events": [
                "FP_HP_SPEC"
            ]
        },
        "fp32_percentage": {
            "title": "Single Precision Floating Point Percentage",
            "formula": "FP_SP_SPEC / INST_SPEC * 100",
            "description": "This metric measures single-precision floating point operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "FP_SP_SPEC",
                "INST_SPEC"
            ],
            "sample_events": [
                "FP_SP_SPEC"
            ]
        },
        "fp64_percentage": {
            "title": "Double Precision Floating Point Percentage",
            "formula": "FP_DP_SPEC / INST_SPEC * 100",
            "description": "This metric measures double-precision floating point operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "FP_DP_SPEC",
                "INST_SPEC"
            ],
            "sample_events": [
                "FP_DP_SPEC"
            ]
        },
        "fp_ops_per_cycle": {
            "title": "Floating Point Operations per Cycle",
            "formula": "(FP_SCALE_OPS_SPEC + FP_FIXED_OPS_SPEC) / CPU_CYCLE",
            "description": "This metric measures floating point operations per cycle in any precision performed by any instruction. Operations are counted by computation and by vector lanes, fused computations such as multiply-add count as twice per vector lane for example.",
            "units": "operations per cycle",
            "events": [
                "FP_FIXED_OPS_SPEC",
                "FP_SCALE_OPS_SPEC"
            ],
            "sample_events": [
                "FP_SCALE_OPS_SPEC",
                "FP_FIXED_OPS_SPEC"
            ]
        },
        "frontend_bound": {
            "title": "Frontend Bound",
            "formula": "(STALL_SLOT_FRONTEND / (5 * CPU_CYCLES) - STALL_FRONTEND_FLUSH / CPU_CYCLES) * 100",
            "description": "This metric is the percentage of total slots that were stalled due to resource constraints in the frontend of the processor.",
            "units": "percent of slots",
            "events": [
                "CPU_CYCLES",
                "STALL_FRONTEND_FLUSH",
                "STALL_SLOT_FRONTEND"
            ],
            "sample_events": [
                "STALL_SLOT_FRONTEND"
            ]
        },
        "frontend_cache_l1i_bound": {
            "title": "Frontend Cache L1I Bound",
            "formula": "STALL_FRONTEND_L1I / (STALL_FRONTEND_L1I + STALL_FRONTEND_MEM) * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to memory access latency issues caused by level 1 instruction cache misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND_L1I",
                "STALL_FRONTEND_MEM"
            ],
            "sample_events": [
                "STALL_FRONTEND_L1I"
            ]
        },
        "frontend_cache_l2i_bound": {
            "title": "Frontend Cache L2I Bound",
            "formula": "STALL_FRONTEND_MEM / (STALL_FRONTEND_L1I + STALL_FRONTEND_MEM) * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to memory access latency issues caused by level 2 instruction cache misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND_L1I",
                "STALL_FRONTEND_MEM"
            ],
            "sample_events": [
                "STALL_FRONTEND_MEM"
            ]
        },
        "frontend_core_bound": {
            "title": "Frontend Core Bound",
            "formula": "STALL_FRONTEND_CPUBOUND / STALL_FRONTEND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to frontend core resource constraints not related to instruction fetch latency issues caused by memory access components.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND",
                "STALL_FRONTEND_CPUBOUND"
            ],
            "sample_events": [
                "STALL_FRONTEND_CPUBOUND"
            ]
        },
        "frontend_core_flow_bound": {
            "title": "Frontend Core Flow Bound",
            "formula": "STALL_FRONTEND_FLOW / STALL_FRONTEND_CPUBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend as the decode unit is awaiting input from the branch prediction unit.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND_CPUBOUND",
                "STALL_FRONTEND_FLOW"
            ],
            "sample_events": [
                "STALL_FRONTEND_FLOW"
            ]
        },
        "frontend_core_flush_bound": {
            "title": "Frontend Core Flush Bound",
            "formula": "STALL_FRONTEND_FLUSH / STALL_FRONTEND_CPUBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend as the processor is recovering from a pipeline flush caused by bad speculation or other machine resteers.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND_CPUBOUND",
                "STALL_FRONTEND_FLUSH"
            ],
            "sample_events": [
                "STALL_FRONTEND_FLUSH"
            ]
        },
        "frontend_mem_bound": {
            "title": "Frontend Memory Bound",
            "formula": "STALL_FRONTEND_MEMBOUND / STALL_FRONTEND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to frontend core resource constraints related to the instruction fetch latency issues caused by memory access components.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND",
                "STALL_FRONTEND_MEMBOUND"
            ],
            "sample_events": [
                "STALL_FRONTEND_MEMBOUND"
            ]
        },
        "frontend_mem_cache_bound": {
            "title": "Frontend Mem Cache Bound",
            "formula": "(STALL_FRONTEND_L1I + STALL_FRONTEND_MEM) / STALL_FRONTEND_MEMBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to instruction fetch latency issues caused by instruction cache misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND_L1I",
                "STALL_FRONTEND_MEM",
                "STALL_FRONTEND_MEMBOUND"
            ],
            "sample_events": [
                "STALL_FRONTEND_MEM",
                "STALL_FRONTEND_L1I"
            ]
        },
        "frontend_mem_tlb_bound": {
            "title": "Frontend Mem TLB Bound",
            "formula": "STALL_FRONTEND_TLB / STALL_FRONTEND_MEMBOUND * 100",
            "description": "This metric is the percentage of total cycles stalled in the frontend due to instruction fetch latency issues caused by instruction TLB misses.",
            "units": "percent of cycles",
            "events": [
                "STALL_FRONTEND_MEMBOUND",
                "STALL_FRONTEND_TLB"
            ],
            "sample_events": [
                "STALL_FRONTEND_TLB"
            ]
        },
        "frontend_stalled_cycles": {
            "title": "Frontend Stalled Cycles",
            "formula": "STALL_FRONTEND / CPU_CYCLES * 100",
            "description": "This metric is the percentage of cycles that were stalled due to resource constraints in the frontend unit of the processor.",
            "units": "percent of cycles",
            "events": [
                "CPU_CYCLES",
                "STALL_FRONTEND"
            ],
            "sample_events": [
                "STALL_FRONTEND"
            ]
        },
        "integer_dp_percentage": {
            "title": "Integer Operations Percentage",
            "formula": "(DP_SPEC - DSB_SPEC) / INST_SPEC * 100",
            "description": "This metric measures scalar integer operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "DP_SPEC",
                "DSB_SPEC",
                "INST_SPEC"
            ],
            "sample_events": [
                "DP_SPEC"
            ]
        },
        "ipc": {
            "title": "Instructions Per Cycle",
            "formula": "INST_RETIRED / CPU_CYCLES",
            "description": "This metric measures the number of instructions retired per cycle.",
            "units": "per cycle",
            "events": [
                "CPU_CYCLES",
                "INST_RETIRED"
            ],
            "sample_events": [
                "INST_RETIRED"
            ]
        },
        "itlb_mpki": {
            "title": "ITLB MPKI",
            "formula": "ITLB_WALK / INST_RETIRED * 1000",
            "description": "This metric measures the number of instruction TLB Walks per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "ITLB_WALK"
            ],
            "sample_events": [
                "ITLB_WALK"
            ]
        },
        "itlb_walk_ratio": {
            "title": "ITLB Walk Ratio",
            "formula": "ITLB_WALK / L1I_TLB",
            "description": "This metric measures the ratio of instruction TLB Walks to the total number of instruction TLB accesses. This gives an indication of the effectiveness of the instruction TLB accesses.",
            "units": "per TLB access",
            "events": [
                "ITLB_WALK",
                "L1I_TLB"
            ],
            "sample_events": [
                "ITLB_WALK"
            ]
        },
        "l1d_cache_miss_ratio": {
            "title": "L1D Cache Miss Ratio",
            "formula": "L1D_CACHE_REFILL / L1D_CACHE",
            "description": "This metric measures the ratio of level 1 data cache accesses missed to the total number of level 1 data cache accesses. This gives an indication of the effectiveness of the level 1 data cache.",
            "units": "per cache access",
            "events": [
                "L1D_CACHE",
                "L1D_CACHE_REFILL"
            ],
            "sample_events": [
                "L1D_CACHE_REFILL"
            ]
        },
        "l1d_cache_mpki": {
            "title": "L1D Cache MPKI",
            "formula": "L1D_CACHE_REFILL / INST_RETIRED * 1000",
            "description": "This metric measures the number of level 1 data cache accesses missed per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "L1D_CACHE_REFILL"
            ],
            "sample_events": [
                "L1D_CACHE_REFILL"
            ]
        },
        "l1d_tlb_miss_ratio": {
            "title": "L1 Data TLB Miss Ratio",
            "formula": "L1D_TLB_REFILL / L1D_TLB",
            "description": "This metric measures the ratio of level 1 data TLB accesses missed to the total number of level 1 data TLB accesses. This gives an indication of the effectiveness of the level 1 data TLB.",
            "units": "per TLB access",
            "events": [
                "L1D_TLB",
                "L1D_TLB_REFILL"
            ],
            "sample_events": [
                "L1D_TLB_REFILL"
            ]
        },
        "l1d_tlb_mpki": {
            "title": "L1 Data TLB MPKI",
            "formula": "L1D_TLB_REFILL / INST_RETIRED * 1000",
            "description": "This metric measures the number of level 1 data TLB accesses missed per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "L1D_TLB_REFILL"
            ],
            "sample_events": [
                "L1D_TLB_REFILL"
            ]
        },
        "l1i_cache_miss_ratio": {
            "title": "L1I Cache Miss Ratio",
            "formula": "L1I_CACHE_REFILL / L1I_CACHE",
            "description": "This metric measures the ratio of level 1 instruction cache accesses missed to the total number of level 1 instruction cache accesses. This gives an indication of the effectiveness of the level 1 instruction cache.",
            "units": "per cache access",
            "events": [
                "L1I_CACHE",
                "L1I_CACHE_REFILL"
            ],
            "sample_events": [
                "L1I_CACHE_REFILL"
            ]
        },
        "l1i_cache_mpki": {
            "title": "L1I Cache MPKI",
            "formula": "L1I_CACHE_REFILL / INST_RETIRED * 1000",
            "description": "This metric measures the number of level 1 instruction cache accesses missed per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "L1I_CACHE_REFILL"
            ],
            "sample_events": [
                "L1I_CACHE_REFILL"
            ]
        },
        "l1i_tlb_miss_ratio": {
            "title": "L1 Instruction TLB Miss Ratio",
            "formula": "L1I_TLB_REFILL / L1I_TLB",
            "description": "This metric measures the ratio of level 1 instruction TLB accesses missed to the total number of level 1 instruction TLB accesses. This gives an indication of the effectiveness of the level 1 instruction TLB.",
            "units": "per TLB access",
            "events": [
                "L1I_TLB",
                "L1I_TLB_REFILL"
            ],
            "sample_events": [
                "L1I_TLB_REFILL"
            ]
        },
        "l1i_tlb_mpki": {
            "title": "L1 Instruction TLB MPKI",
            "formula": "L1I_TLB_REFILL / INST_RETIRED * 1000",
            "description": "This metric measures the number of level 1 instruction TLB accesses missed per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "L1I_TLB_REFILL"
            ],
            "sample_events": [
                "L1I_TLB_REFILL"
            ]
        },
        "l2_cache_miss_ratio": {
            "title": "L2 Cache Miss Ratio",
            "formula": "L2D_CACHE_REFILL / L2D_CACHE",
            "description": "This metric measures the ratio of level 2 cache accesses missed to the total number of level 2 cache accesses. This gives an indication of the effectiveness of the level 2 cache, which is a unified cache that stores both data and instruction. Note that cache accesses in this cache are either data memory access or instruction fetch as this is a unified cache.",
            "units": "per cache access",
            "events": [
                "L2D_CACHE",
                "L2D_CACHE_REFILL"
            ],
            "sample_events": [
                "L2D_CACHE_REFILL"
            ]
        },
        "l2_cache_mpki": {
            "title": "L2 Cache MPKI",
            "formula": "L2D_CACHE_REFILL / INST_RETIRED * 1000",
            "description": "This metric measures the number of level 2 unified cache accesses missed per thousand instructions executed. Note that cache accesses in this cache are either data memory access or instruction fetch as this is a unified cache.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "L2D_CACHE_REFILL"
            ],
            "sample_events": [
                "L2D_CACHE_REFILL"
            ]
        },
        "l2_tlb_miss_ratio": {
            "title": "L2 Unified TLB Miss Ratio",
            "formula": "L2D_TLB_REFILL / L2D_TLB",
            "description": "This metric measures the ratio of level 2 unified TLB accesses missed to the total number of level 2 unified TLB accesses. This gives an indication of the effectiveness of the level 2 TLB.",
            "units": "per TLB access",
            "events": [
                "L2D_TLB",
                "L2D_TLB_REFILL"
            ],
            "sample_events": [
                "L2D_TLB_REFILL"
            ]
        },
        "l2_tlb_mpki": {
            "title": "L2 Unified TLB MPKI",
            "formula": "L2D_TLB_REFILL / INST_RETIRED * 1000",
            "description": "This metric measures the number of level 2 unified TLB accesses missed per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "L2D_TLB_REFILL"
            ],
            "sample_events": [
                "L2D_TLB_REFILL"
            ]
        },
        "ll_cache_read_hit_ratio": {
            "title": "LL Cache Read Hit Ratio",
            "formula": "(LL_CACHE_RD - LL_CACHE_MISS_RD) / LL_CACHE_RD",
            "description": "This metric measures the ratio of last level cache read accesses hit in the cache to the total number of last level cache accesses. This gives an indication of the effectiveness of the last level cache for read traffic. Note that cache accesses in this cache are either data memory access or instruction fetch as this is a system level cache.",
            "units": "per cache access",
            "events": [
                "LL_CACHE_MISS_RD",
                "LL_CACHE_RD"
            ],
            "sample_events": [
                "LL_CACHE_MISS_RD"
            ]
        },
        "ll_cache_read_miss_ratio": {
            "title": "LL Cache Read Miss Ratio",
            "formula": "LL_CACHE_MISS_RD / LL_CACHE_RD",
            "description": "This metric measures the ratio of last level cache read accesses missed to the total number of last level cache accesses. This gives an indication of the effectiveness of the last level cache for read traffic. Note that cache accesses in this cache are either data memory access or instruction fetch as this is a system level cache.",
            "units": "per cache access",
            "events": [
                "LL_CACHE_MISS_RD",
                "LL_CACHE_RD"
            ],
            "sample_events": [
                "LL_CACHE_MISS_RD"
            ]
        },
        "ll_cache_read_mpki": {
            "title": "LL Cache Read MPKI",
            "formula": "LL_CACHE_MISS_RD / INST_RETIRED * 1000",
            "description": "This metric measures the number of last level cache read accesses missed per thousand instructions executed.",
            "units": "MPKI",
            "events": [
                "INST_RETIRED",
                "LL_CACHE_MISS_RD"
            ],
            "sample_events": [
                "LL_CACHE_MISS_RD"
            ]
        },
        "load_percentage": {
            "title": "Load Operations Percentage",
            "formula": "LD_SPEC / INST_SPEC * 100",
            "description": "This metric measures load operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "INST_SPEC",
                "LD_SPEC"
            ],
            "sample_events": [
                "LD_SPEC"
            ]
        },
        "nonsve_fp_ops_per_cycle": {
            "title": "Non-SVE Floating Point Operations per Cycle",
            "formula": "FP_FIXED_OPS_SPEC / CPU_CYCLE",
            "description": "This metric measures floating point operations per cycle in any precision performed by an instruction that is not an SVE instruction. Operations are counted by computation and by vector lanes, fused computations such as multiply-add count as twice per vector lane for example.",
            "units": "operations per cycle",
            "events": [
                "FP_FIXED_OPS_SPEC"
            ],
            "sample_events": [
                "FP_FIXED_OPS_SPEC"
            ]
        },
        "retiring": {
            "title": "Retiring",
            "formula": "(1 - STALL_SLOT / (CPU_CYCLES * 5)) * (OP_RETIRED / OP_SPEC) * 100",
            "description": "This metric is the percentage of total slots that retired operations, which indicates cycles that were utilized efficiently.",
            "units": "percent of slots",
            "events": [
                "CPU_CYCLES",
                "OP_RETIRED",
                "OP_SPEC",
                "STALL_SLOT"
            ],
            "sample_events": [
                "OP_RETIRED"
            ]
        },
        "scalar_fp_percentage": {
            "title": "Floating Point Operations Percentage",
            "formula": "VFP_SPEC / INST_SPEC * 100",
            "description": "This metric measures scalar floating point operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "INST_SPEC",
                "VFP_SPEC"
            ],
            "sample_events": [
                "VFP_SPEC"
            ]
        },
        "simd_percentage": {
            "title": "Advanced SIMD Operations Percentage",
            "formula": "ASE_SPEC / INST_SPEC * 100",
            "description": "This metric measures advanced SIMD operations as a percentage of total operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "ASE_SPEC",
                "INST_SPEC"
            ],
            "sample_events": [
                "ASE_SPEC"
            ]
        },
        "store_percentage": {
            "title": "Store Operations Percentage",
            "formula": "ST_SPEC / INST_SPEC * 100",
            "description": "This metric measures store operations as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "INST_SPEC",
                "ST_SPEC"
            ],
            "sample_events": [
                "ST_SPEC"
            ]
        },
        "sve_all_percentage": {
            "title": "SVE Operations (Load/Store Inclusive) Percentage",
            "formula": "SVE_INST_SPEC / INST_SPEC * 100",
            "description": "This metric measures scalable vector operations, including loads and stores, as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "INST_SPEC",
                "SVE_INST_SPEC"
            ],
            "sample_events": [
                "SVE_INST_SPEC"
            ]
        },
        "sve_fp_ops_per_cycle": {
            "title": "SVE Floating Point Operations per Cycle",
            "formula": "FP_SCALE_OPS_SPEC / CPU_CYCLE",
            "description": "This metric measures floating point operations per cycle in any precision performed by SVE instructions. Operations are counted by computation and by vector lanes, fused computations such as multiply-add count as twice per vector lane for example.",
            "units": "operations per cycle",
            "events": [
                "FP_SCALE_OPS_SPEC"
            ],
            "sample_events": [
                "FP_SCALE_OPS_SPEC"
            ]
        },
        "sve_predicate_empty_percentage": {
            "title": "SVE Empty Predicate Percentage",
            "formula": "SVE_PRED_EMPTY_SPEC / SVE_PRED_SPEC * 100",
            "description": "This metric measures scalable vector operations with no active predicates as a percentage of sve predicated operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "SVE_PRED_EMPTY_SPEC",
                "SVE_PRED_SPEC"
            ],
            "sample_events": [
                "SVE_PRED_EMPTY_SPEC"
            ]
        },
        "sve_predicate_full_percentage": {
            "title": "SVE Full Predicate Percentage",
            "formula": "SVE_PRED_FULL_SPEC / SVE_PRED_SPEC * 100",
            "description": "This metric measures scalable vector operations with all active predicates as a percentage of sve predicated operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "SVE_PRED_FULL_SPEC",
                "SVE_PRED_SPEC"
            ],
            "sample_events": [
                "SVE_PRED_FULL_SPEC"
            ]
        },
        "sve_predicate_partial_percentage": {
            "title": "SVE Partial Predicate Percentage",
            "formula": "SVE_PRED_PARTIAL_SPEC / SVE_PRED_SPEC * 100",
            "description": "This metric measures scalable vector operations with at least one active predicates as a percentage of sve predicated operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "SVE_PRED_PARTIAL_SPEC",
                "SVE_PRED_SPEC"
            ],
            "sample_events": [
                "SVE_PRED_PARTIAL_SPEC"
            ]
        },
        "sve_predicate_percentage": {
            "title": "SVE Predicate Percentage",
            "formula": "SVE_PRED_SPEC / INST_SPEC * 100",
            "description": "This metric measures scalable vector operations with predicates as a percentage of operations speculatively executed.",
            "units": "percent of operations",
            "events": [
                "INST_SPEC",
                "SVE_PRED_SPEC"
            ],
            "sample_events": [
                "SVE_PRED_SPEC"
            ]
        }
    },
    "groups": {
        "function": {
            "Bus": {
                "title": "BUS",
                "description": "Bus transaction related events",
                "events": [
                    "BUS_ACCESS",
                    "BUS_ACCESS_RD",
                    "BUS_ACCESS_WR",
                    "BUS_CYCLES"
                ]
            },
            "Chain": {
                "title": "CHAIN",
                "description": "Chain related events",
                "events": [
                    "CHAIN"
                ]
            },
            "Exception": {
                "title": "EXCEPTION",
                "description": "Exception related events",
                "events": [
                    "EXC_DABORT",
                    "EXC_FIQ",
                    "EXC_HVC",
                    "EXC_IRQ",
                    "EXC_PABORT",
                    "EXC_RETURN",
                    "EXC_SMC",
                    "EXC_SVC",
                    "EXC_TAKEN",
                    "EXC_TRAP_DABORT",
                    "EXC_TRAP_FIQ",
                    "EXC_TRAP_IRQ",
                    "EXC_TRAP_OTHER",
                    "EXC_TRAP_PABORT",
                    "EXC_UNDEF"
                ]
            },
            "L1D_Cache": {
                "title": "L1D CACHE",
                "description": "L1 data cache related events",
                "events": [
                    "L1D_CACHE",
                    "L1D_CACHE_HWPRF",
                    "L1D_CACHE_INVAL",
                    "L1D_CACHE_LMISS_RD",
                    "L1D_CACHE_RD",
                    "L1D_CACHE_REFILL",
                    "L1D_CACHE_REFILL_HWPRF",
                    "L1D_CACHE_REFILL_INNER",
                    "L1D_CACHE_REFILL_OUTER",
                    "L1D_CACHE_RW",
                    "L1D_CACHE_WB",
                    "L1D_CACHE_WR"
                ]
            },
            "L1I_Cache": {
                "title": "L1I CACHE",
                "description": "L1 instruction cache related events",
                "events": [
                    "L1I_CACHE",
                    "L1I_CACHE_LMISS",
                    "L1I_CACHE_REFILL"
                ]
            },
            "L2_Cache": {
                "title": "L2 CACHE",
                "description": "L2 unified cache related events",
                "events": [
                    "L2D_CACHE",
                    "L2D_CACHE_ALLOCATE",
                    "L2D_CACHE_INVAL",
                    "L2D_CACHE_LMISS_RD",
                    "L2D_CACHE_PRF",
                    "L2D_CACHE_RD",
                    "L2D_CACHE_REFILL",
                    "L2D_CACHE_REFILL_PRF",
                    "L2D_CACHE_REFILL_RD",
                    "L2D_CACHE_REFILL_WR",
                    "L2D_CACHE_RW",
                    "L2D_CACHE_WB",
                    "L2D_CACHE_WB_CLEAN",
                    "L2D_CACHE_WB_VICTIM",
                    "L2D_CACHE_WR",
                    "L2I_CACHE",
                    "L2I_CACHE_LMISS",
                    "L2I_CACHE_RD",
                    "L2I_CACHE_REFILL"
                ]
            },
            "L3_Cache": {
                "title": "L3 CACHE",
                "description": "L3 unified cache related events",
                "events": [
                    "L3D_CACHE",
                    "L3D_CACHE_ALLOCATE",
                    "L3D_CACHE_LMISS_RD",
                    "L3D_CACHE_MISS",
                    "L3D_CACHE_RD",
                    "L3D_CACHE_REFILL"
                ]
            },
            "LL_Cache": {
                "title": "LL CACHE",
                "description": "Last Level Cache related events",
                "events": [
                    "LL_CACHE",
                    "LL_CACHE_MISS",
                    "LL_CACHE_MISS_RD",
                    "LL_CACHE_RD",
                    "LL_CACHE_REFILL"
                ]
            },
            "Memory": {
                "title": "MEMORY",
                "description": "Memory system related events",
                "events": [
                    "INST_FETCH",
                    "INST_FETCH_PERCYC",
                    "LDST_ALIGN_LAT",
                    "LD_ALIGN_LAT",
                    "MEM_ACCESS",
                    "MEM_ACCESS_CHECKED",
                    "MEM_ACCESS_RD",
                    "MEM_ACCESS_CHECKED_RD",
                    "MEM_ACCESS_RD_PERCYC",
                    "MEM_ACCESS_WR",
                    "MEM_ACCESS_CHECKED_WR",
                    "REMOTE_ACCESS",
                    "ST_ALIGN_LAT"
                ]
            },
            "Retired": {
                "title": "RETIRED",
                "description": "Retired instruction and operation events",
                "events": [
                    "BR_IMMED_MIS_PRED_RETIRED",
                    "BR_IMMED_PRED_RETIRED",
                    "BR_IMMED_RETIRED",
                    "BR_IMMED_TAKEN_RETIRED",
                    "BR_INDNR_MIS_PRED_RETIRED",
                    "BR_INDNR_PRED_RETIRED",
                    "BR_INDNR_TAKEN_RETIRED",
                    "BR_IND_MIS_PRED_RETIRED",
                    "BR_IND_PRED_RETIRED",
                    "BR_IND_RETIRED",
                    "BR_MIS_PRED_RETIRED",
                    "BR_PRED_RETIRED",
                    "BR_RETIRED",
                    "BR_RETURN_MIS_PRED_RETIRED",
                    "BR_RETURN_PRED_RETIRED",
                    "BR_RETURN_RETIRED",
                    "CID_WRITE_RETIRED",
                    "INST_RETIRED",
                    "OP_RETIRED",
                    "PC_WRITE_RETIRED",
                    "SW_INCR",
                    "TTBR_WRITE_RETIRED"
                ]
            },
            "SPE": {
                "title": "SPE",
                "description": "SPE related events",
                "events": [
                    "SAMPLE_COLLISION",
                    "SAMPLE_FEED",
                    "SAMPLE_FEED_BR",
                    "SAMPLE_FEED_EVENT",
                    "SAMPLE_FEED_LAT",
                    "SAMPLE_FEED_LD",
                    "SAMPLE_FEED_OP",
                    "SAMPLE_FEED_ST",
                    "SAMPLE_FILTRATE",
                    "SAMPLE_POP"
                ]
            },
            "Spec_Operation": {
                "title": "SPEC OPERATION",
                "description": "Speculatively executed operations related events",
                "events": [
                    "ASE_INST_SPEC",
                    "ASE_SPEC",
                    "BR_MIS_PRED",
                    "BR_PRED",
                    "CAS_FAR_SPEC",
                    "CAS_NEAR_PASS",
                    "CAS_NEAR_SPEC",
                    "CRYPTO_SPEC",
                    "DMB_SPEC",
                    "DP_SPEC",
                    "DSB_SPEC",
                    "INST_SPEC",
                    "ISB_SPEC",
                    "LD_SPEC",
                    "OP_SPEC",
                    "PC_WRITE_SPEC",
                    "RC_LD_SPEC",
                    "RC_ST_SPEC",
                    "STREX_FAIL_SPEC",
                    "STREX_SPEC",
                    "ST_SPEC",
                    "VFP_SPEC"
                ]
            },
            "FP_Operation": {
                "title": "FP OPERATION",
                "description": "Speculatively executed floating-point events",
                "events": [
                    "FP_DP_SPEC",
                    "FP_FIXED_OPS_SPEC",
                    "FP_HP_SPEC",
                    "FP_SCALE_OPS_SPEC",
                    "FP_SP_SPEC"
                ]
            },
            "Stall": {
                "title": "STALL",
                "description": "Stall related events",
                "events": [
                    "STALL",
                    "STALL_BACKEND",
                    "STALL_BACKEND_BUSY",
                    "STALL_BACKEND_CPUBOUND",
                    "STALL_BACKEND_L1D",
                    "STALL_BACKEND_MEM",
                    "STALL_BACKEND_MEMBOUND",
                    "STALL_BACKEND_RENAME",
                    "STALL_BACKEND_ST",
                    "STALL_BACKEND_TLB",
                    "STALL_FRONTEND",
                    "STALL_FRONTEND_CPUBOUND",
                    "STALL_FRONTEND_FLOW",
                    "STALL_FRONTEND_FLUSH",
                    "STALL_FRONTEND_L1I",
                    "STALL_FRONTEND_MEM",
                    "STALL_FRONTEND_MEMBOUND",
                    "STALL_FRONTEND_TLB",
                    "STALL_SLOT",
                    "STALL_SLOT_BACKEND",
                    "STALL_SLOT_FRONTEND"
                ]
            },
            "General": {
                "title": "GENERAL",
                "description": "General CPU related events",
                "events": [
                    "CNT_CYCLES",
                    "CPU_CYCLES"
                ]
            },
            "TLB": {
                "title": "TLB",
                "description": "TLB and MMU related events",
                "events": [
                    "DTLB_HWUPD",
                    "DTLB_STEP",
                    "DTLB_WALK",
                    "DTLB_WALK_LARGE",
                    "DTLB_WALK_PERCYC",
                    "DTLB_WALK_SMALL",
                    "ITLB_HWUPD",
                    "ITLB_STEP",
                    "ITLB_WALK",
                    "ITLB_WALK_LARGE",
                    "ITLB_WALK_PERCYC",
                    "ITLB_WALK_SMALL",
                    "L1D_TLB",
                    "L1D_TLB_REFILL",
                    "L1I_TLB",
                    "L1I_TLB_REFILL",
                    "L2D_TLB",
                    "L2D_TLB_REFILL"
                ]
            },
            "SVE": {
                "title": "SVE",
                "description": "SVE related events",
                "events": [
                    "ASE_SVE_INT16_SPEC",
                    "ASE_SVE_INT32_SPEC",
                    "ASE_SVE_INT64_SPEC",
                    "ASE_SVE_INT8_SPEC",
                    "SVE_INST_SPEC",
                    "SVE_LDFF_FAULT_SPEC",
                    "SVE_LDFF_SPEC",
                    "SVE_PRED_EMPTY_SPEC",
                    "SVE_PRED_FULL_SPEC",
                    "SVE_PRED_NOT_FULL_SPEC",
                    "SVE_PRED_PARTIAL_SPEC",
                    "SVE_PRED_SPEC"
                ]
            },
            "Non_PMU": {
                "title": "NON_PMU",
                "description": "Non-PMU related events",
                "events": [
                    "PMU_HOVFS",
                    "PMU_OVFS"
                ]
            },
            "TRACE": {
                "title": "TRACE",
                "description": "Trace related events",
                "events": [
                    "CTI_TRIGOUT4",
                    "CTI_TRIGOUT5",
                    "CTI_TRIGOUT6",
                    "CTI_TRIGOUT7",
                    "TRB_TRIG",
                    "TRB_WRAP",
                    "TRCEXTOUT0",
                    "TRCEXTOUT1",
                    "TRCEXTOUT2",
                    "TRCEXTOUT3"
                ]
            }
        },
        "metrics": {
            "Topdown_L1": {
                "title": "Topdown Level 1",
                "description": "This metric group contains the first set of metrics to begin topdown analysis of application performance, which provide the percentage distribution of processor pipeline utilization.",
                "metrics": [
                    "frontend_bound",
                    "backend_bound",
                    "retiring",
                    "bad_speculation"
                ]
            },
            "Topdown_Frontend": {
                "title": "Topdown Frontend",
                "description": "This metric group contains a set of metrics to analyse a frontend bound workload.",
                "metrics": [
                    "frontend_core_bound",
                    "frontend_mem_bound",
                    "frontend_core_flush_bound",
                    "frontend_core_flow_bound",
                    "frontend_mem_cache_bound",
                    "frontend_mem_tlb_bound",
                    "frontend_cache_l1i_bound",
                    "frontend_cache_l2i_bound"
                ]
            },
            "Topdown_Backend": {
                "title": "Topdown Backend",
                "description": "This metric group contains a set of metrics to analyze a backend bound workload.",
                "metrics": [
                    "backend_core_bound",
                    "backend_mem_bound",
                    "backend_core_rename_bound",
                    "backend_busy_bound",
                    "backend_mem_cache_bound",
                    "backend_mem_tlb_bound",
                    "backend_mem_store_bound",
                    "backend_cache_l1d_bound",
                    "backend_cache_l2d_bound"
                ]
            },
            "Cycle_Accounting": {
                "title": "Cycle Accounting",
                "description": "This metric group contains a set of metrics that measure the percentage of processor cycles stalled in either frontend or backend of the processor.",
                "metrics": [
                    "frontend_stalled_cycles",
                    "backend_stalled_cycles"
                ]
            },
            "General": {
                "title": "General",
                "description": "This metric group contains general CPU metrics for performance analysis.",
                "metrics": [
                    "ipc"
                ]
            },
            "MPKI": {
                "title": "Misses Per Kilo Instructions",
                "description": "This metric group contains metrics for different CPU resources that can be measured as misses per kilo instructions.",
                "metrics": [
                    "branch_mpki",
                    "itlb_mpki",
                    "l1i_tlb_mpki",
                    "dtlb_mpki",
                    "l1d_tlb_mpki",
                    "l2_tlb_mpki",
                    "l1i_cache_mpki",
                    "l1d_cache_mpki",
                    "l2_cache_mpki",
                    "ll_cache_read_mpki"
                ]
            },
            "Miss_Ratio": {
                "title": "Miss Ratio",
                "description": "This metric group contains metrics to measure miss ratios of different processor resources.",
                "metrics": [
                    "branch_misprediction_ratio",
                    "itlb_walk_ratio",
                    "dtlb_walk_ratio",
                    "l1i_tlb_miss_ratio",
                    "l1d_tlb_miss_ratio",
                    "l2_tlb_miss_ratio",
                    "l1i_cache_miss_ratio",
                    "l1d_cache_miss_ratio",
                    "l2_cache_miss_ratio",
                    "ll_cache_read_miss_ratio"
                ]
            },
            "SVE_Effectiveness": {
                "title": "SVE Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of predicated SVE instruction execution on this processor.",
                "metrics": [
                    "sve_predicate_percentage",
                    "sve_predicate_full_percentage",
                    "sve_predicate_partial_percentage",
                    "sve_predicate_empty_percentage"
                ]
            },
            "FP_Arithmetic_Intensity": {
                "title": "Floating Point Arithmetic Intensity",
                "description": "This metric group contains metrics to evaluate the effectiveness of floating point instruction execution on this processor.",
                "metrics": [
                    "sve_fp_ops_per_cycle",
                    "nonsve_fp_ops_per_cycle",
                    "fp_ops_per_cycle"
                ]
            },
            "FP_Precision_Mix": {
                "title": "Floating Point Precision",
                "description": "This metric group contains metrics to evaluate the precision of floating point instruction execution on this processor.",
                "metrics": [
                    "fp16_percentage",
                    "fp32_percentage",
                    "fp64_percentage"
                ]
            },
            "Branch_Effectiveness": {
                "title": "Branch Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of branch instruction execution on this processor.",
                "metrics": [
                    "branch_mpki",
                    "branch_direct_ratio",
                    "branch_indirect_ratio",
                    "branch_return_ratio",
                    "branch_misprediction_ratio"
                ]
            },
            "ITLB_Effectiveness": {
                "title": "Instruction TLB Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of instruction TLB on this processor.",
                "metrics": [
                    "itlb_mpki",
                    "l1i_tlb_mpki",
                    "l2_tlb_mpki",
                    "itlb_walk_ratio",
                    "l1i_tlb_miss_ratio",
                    "l2_tlb_miss_ratio"
                ]
            },
            "DTLB_Effectiveness": {
                "title": "Data TLB Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of data TLB on this processor.",
                "metrics": [
                    "dtlb_mpki",
                    "l1d_tlb_mpki",
                    "l2_tlb_mpki",
                    "dtlb_walk_ratio",
                    "l1d_tlb_miss_ratio",
                    "l2_tlb_miss_ratio"
                ]
            },
            "L1I_Cache_Effectiveness": {
                "title": "L1 Instruction Cache Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of L1 Instruction cache on this processor.",
                "metrics": [
                    "l1i_cache_mpki",
                    "l1i_cache_miss_ratio"
                ]
            },
            "L1D_Cache_Effectiveness": {
                "title": "L1 Data Cache Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of L1 Data Cache on this processor.",
                "metrics": [
                    "l1d_cache_mpki",
                    "l1d_cache_miss_ratio"
                ]
            },
            "L2_Cache_Effectiveness": {
                "title": "L2 Unified Cache Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of L2 Unified Cache on this processor.",
                "metrics": [
                    "l2_cache_mpki",
                    "l2_cache_miss_ratio"
                ]
            },
            "LL_Cache_Effectiveness": {
                "title": "Last Level Cache Effectiveness",
                "description": "This metric group contains metrics to evaluate the effectiveness of Last Level Cache on this processor.",
                "metrics": [
                    "ll_cache_read_mpki",
                    "ll_cache_read_miss_ratio",
                    "ll_cache_read_hit_ratio"
                ]
            },
            "Operation_Mix": {
                "title": "Speculative Operation Mix",
                "description": "This metric group provides the distribution of micro-operation types executed for the program.",
                "metrics": [
                    "load_percentage",
                    "store_percentage",
                    "integer_dp_percentage",
                    "simd_percentage",
                    "scalar_fp_percentage",
                    "barrier_percentage",
                    "branch_percentage",
                    "crypto_percentage",
                    "sve_all_percentage"
                ]
            }
        }
    },
    "methodologies": {
        "topdown_methodology": {
            "title": "Topdown Methodology",
            "description": "Topdown Performance Analysis Methodology",
            "metric_grouping": {
                "stage_1": [
                    "Topdown_L1",
                    "Topdown_Frontend",
                    "Topdown_Backend"
                ],
                "stage_2": [
                    "Cycle_Accounting",
                    "General",
                    "MPKI",
                    "Miss_Ratio",
                    "SVE_Effectiveness",
                    "FP_Arithmetic_Intensity",
                    "FP_Precision_Mix",
                    "Branch_Effectiveness",
                    "ITLB_Effectiveness",
                    "DTLB_Effectiveness",
                    "L1I_Cache_Effectiveness",
                    "L1D_Cache_Effectiveness",
                    "L2_Cache_Effectiveness",
                    "LL_Cache_Effectiveness",
                    "Operation_Mix"
                ]
            },
            "decision_tree": {
                "root_nodes": [
                    "frontend_bound",
                    "backend_bound",
                    "retiring",
                    "bad_speculation"
                ],
                "metrics": [
                    {
                        "name": "frontend_bound",
                        "group": "Topdown_L1",
                        "next_items": [
                            "frontend_core_bound",
                            "frontend_mem_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_bound",
                        "group": "Topdown_L1",
                        "next_items": [
                            "backend_core_bound",
                            "backend_mem_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "retiring",
                        "group": "Topdown_L1",
                        "next_items": [
                            "Operation_Mix"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "bad_speculation",
                        "group": "Topdown_L1",
                        "next_items": [
                            "Branch_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_core_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "frontend_core_flush_bound",
                            "frontend_core_flow_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_mem_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "frontend_mem_cache_bound",
                            "frontend_mem_tlb_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_core_flush_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "Branch_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_core_flow_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "Branch_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_mem_cache_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "frontend_cache_l1i_bound",
                            "frontend_cache_l2i_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_mem_tlb_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "ITLB_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_cache_l1i_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "L1I_Cache_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "frontend_cache_l2i_bound",
                        "group": "Topdown_Frontend",
                        "next_items": [
                            "L2_Cache_Effectiveness",
                            "LL_Cache_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_core_bound",
                        "group": "Topdown_Backend",
                        "next_items": [
                            "backend_core_rename_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_mem_bound",
                        "group": "Topdown_Backend",
                        "next_items": [
                            "backend_mem_cache_bound",
                            "backend_mem_tlb_bound",
                            "backend_mem_store_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_core_rename_bound",
                        "group": "Topdown_Backend",
                        "next_items": [],
                        "sample_events": []
                    },
                    {
                        "name": "backend_busy_bound",
                        "group": "Topdown_Backend",
                        "next_items": [],
                        "sample_events": []
                    },
                    {
                        "name": "backend_mem_cache_bound",
                        "group": "Topdown_Backend",
                        "next_items": [
                            "backend_cache_l1d_bound",
                            "backend_cache_l2d_bound"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_mem_tlb_bound",
                        "group": "Topdown_Backend",
                        "next_items": [
                            "DTLB_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_mem_store_bound",
                        "group": "Topdown_Backend",
                        "next_items": [],
                        "sample_events": []
                    },
                    {
                        "name": "backend_cache_l1d_bound",
                        "group": "Topdown_Backend",
                        "next_items": [
                            "L1D_Cache_Effectiveness"
                        ],
                        "sample_events": []
                    },
                    {
                        "name": "backend_cache_l2d_bound",
                        "group": "Topdown_Backend",
                        "next_items": [
                            "L2_Cache_Effectiveness",
                            "LL_Cache_Effectiveness"
                        ],
                        "sample_events": []
                    }
                ]
            }
        }
    }
}